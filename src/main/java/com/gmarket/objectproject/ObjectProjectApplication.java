package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 상속의 목적은 코드 재사용이 아니다 -> 상속은 타입 계층을 구조화하기 위해 사용해야 한다.
 * 상속을 사용하는 목적이 단순히 코드를 재사용하기 위해서인가? 아니면 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서인가 알아야한다 -> 코드를 재사용하기 위해서는 사용하면 안된닫.
 *
 * 다형성
 * 많은(poly) + 형태(morphism) 을 합성어로 많은 형태를 가질 수 있는 능력을 의미한다.
 * -> 컴퓨터 과학에서는 다형성을 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의한다.
 * 다형성은 유니버셜/임시 다형성으로 분리되고 유니버셜 다형성은 매개변수/포함 다형성, 임시 다형성은 오버로딩/강제 다형성으로 분류한다.
 * 오버로딩 다형성: 하나의 클래스안에 동일한 이름의 메서드가 존재하는 경우 -> 유사한 작업을 수행하는 메서드의 이름을 통일할 수 있기 때문에 기억해야 하는 이름의 수를 극적으로 줄일 수 있다.
 * 강제 다형성: 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리키낟.
 * -> 일반적으로 오버로딩 다형성과 강제 다형성을 함께 사용하면 모호해질 수 있는데 실제로 어떤 메서드가 호출될지를 판단하기 어렵기 때문이다.
 * 매개변수 다형성: 제네릭 프로그래밍과 관련이 높은데 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식을 가리킨다.
 * 포함 다형성: 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미한다. -> 포함 다형성은 서브타입 다형성이라고 부른다.
 * 포함 다형성을 구현하는 가장 일반적인 방법은 상속을 이용하는 것으로 두 클래스를 상속 관계로 연결하고 자식 클래스에서 부모 클래스의 메서드를 오버라이딩한 후 클라이언트는 부모 클래스만 참조하면 포함 다형성을 구현할 수 있다.
 * 포함 다형성을 전제 조건은 자식 클래스가 부모 클래스의 서브타입이어야한다는 것이다. 그리고 상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다.
 * 포함 다형성을 위해 상속을 사용하는 이유는 상속이 클래스들을 계층으로 쌓아 올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공하기 때문이다.
 * 객체가 메시지를 수신하려면 객체지향 시스템은 메시지를 처리할 적절한 메서드를 상속계층 안에서 탐색한다
 * 실행할 메서드를 선택하는 기준은 어떤 메시지를 수신했는지에 따라 어떤 클래스의 인스턴스인지에 따라 상속 계층이 어떻게 구성돼 있는지에 따라 달라진다
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
