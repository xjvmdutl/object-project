package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 데이터 중심 설계 -> 책임 주도 설계로 변경하기 위한 원칙
 * - 데이터보다 행동을 먼저 결정하라
 * - 협력이라는 문맥안에서 책임을 결정하라
 *
 * 데이터보다 행동을 먼저 결정하라
 * 객체에게 주요한 것은 데이터가 아닌 외부에 제공하는 행동이다. 클라이언트 관점에선 객체가 수행하는 행동이란 객체의 책임을 의미하며, 객체는 협력에 참여하기 위해 존재하며 협력 안에서 수행하는 책임이 객체의 존재가치를 증명한다.
 * 너무 이른 시기에 데이터에 초점을 맞추면 객체의 캡슐화가 약화되기 떄문에 낮은 응집도와 높은 결합도를 가진 객체들로 넘처나게 된다 -> 변경에 취약한 설계를 가지고 온다.
 * 책임 중심의 설계에서는 객체의 행동, 즉 책임을 먼저 결정한 후에 객체의 상태를 결정해야 한다.
 *
 * 협력이라는 문맥 안에서 책임을 결정하라
 * 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야한다.
 * 협력을 시작하는 주체는 메시지 전송자이기 떄문에 협력에 적합한 책임이란 메시지 수신자가 아니라 전송자에게 적합한 책임을 의미한다 -> 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야한다.
 * 협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후 메시지를 선택하는 것이 아닌 메시지를 결정한 후 객체를 선택해야한다.
 * 메시지는 클라이언트의 의도를 표현하며, 객체를 결정하기 전에 객체가 수신할 메시지를 먼저 결정한다.
 * 클라이언트는 어떤 객체가 메시지를 수신할지 알지 못하며, 단지 임의의 객체가 메시지를 수신할 것이라고 믿고 자신의 의도를 표현한 메시지를 전송할 뿐이다.-> 메시지를 수신하기로한 객체는 메시지를 처리할 책임을 할당받게 된다.
 * 메시지를 먼저 결정하기 때문에 메시지 송신자는 수신자에 대한 어떠한 가정도 할 수 없으며, 메시지 전송자의 관점에서는 수신자는 깔끔하게 캡슐화 되는것이다.
 *
 * 책임 주도 설계
 * - 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
 * - 시스템 책임을 더 작은 책임으로 분할한다.
 * - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
 * - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
 * - 해당 객체 또는 역할에게 책임을 할당함으로서 두 객체가 협력하게 된다.
 * 책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것으로 협력에 참여하는 객체들의 책임이 어느 정도 정리될 때까지는 객체의 내부 상태에 대해 관심을 가지지 않는것이다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
