package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 합성이 상속과 같은 문제점을 초래하지 않는 이유는 클래스의 구체적인 구현이 아니라 객체의 추상적인 인터페이스에 의존하기 때문이다.
 * 상속과 클래스를 기반으로 하는 재사용 방법을 사용하면 클래스의 확장과 수정을 일관성 있게 표현할 수 있는 추상화의 부족으로 인해 변경하기 어려운 코드를 얻게 된다.
 * 믹스인은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어다. -> 합성이 실행 시점에 객체를 조합하는 재사용 방법이면, 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.
 * 믹스인은 말 그대로 코드를 다른 코드안에 섞어 넣기 위한 방법인데, 유연하게 관계를 재구성 할 수 있다.
 *
 * 트레이트로 부가 정책 구현하기
 * 상속은 정적이지만 믹스인은 동적이다. -> 상속은 부모 클래스와 자식 클래스의 관계를 코드를 작성하는 시점에 고정시켜 버리지만 믹스인은 제약을 둘 뿐 실제로 어떤 코드에 믹스인될 것인지를 결정하지 않는다.
 * TaxablePolicy 트레이트는 어떤 코드에 믹스인될 것인가? -> 실제로 트레이트를 믹스인하는 시점에 가서야 믹스인할 대상을 결정할 수 있다.
 * super 호출로 실행되는 메서드 역시 실제로 트레이트가 믹스인 되는 시점에 결정된다.
 * super 참조가 가리키는 대상이 컴파일 시점이 아닌 실행 시점에 결정된다는 것을 의미한다.
 * 상속의 경우 일반적으로 this 참조는 동적으로 결정되지만 super 참조는 컴파일 시점에 결정된다. 따라서 상속에서는 부모 클래스와 자식 클래스 관계를 변경할 수 있는 방법은 없다.
 * 하지만 스칼라의 트레이트에서 super 참조는 동적으로 결정된다. 따라서 트레이트의 경우 this 호출뿐만 아니라 super 호출 역시 실행 시점에 바인딩 된다.
 * 믹스인은 독립적으로 작성된 트레이트와 클래스를 코드 작성 시점에 조합해서 더 큰 기능을 만들어낼 수 있다.
 *
 * 부가 정책 트레이트 믹스인하기
 * 스칼라는 트레이트를 클래스나 다른 트레이트에 믹스인 할 수 있도록 extends와 with 키워드를 제공한다.
 * 믹스인하려는 대상 클래스의 부모 클래스가 존재하는 경우 부모 클래스는 extends를 이용해 상속받고 트레이트는 with를 이용해 믹스인해야한다. -> 트레이트 조합
 * 스칼라는 특정 클래스에 믹스인한 클래스와 트레이트를 선형화해서 어떤 메서드를 호출할지 결정한다.
 * 클래스의 인스턴스를 생성할 때 스칼라는 클래스 자신과 조상 클래스, 트레이트를 일렬로 나열해서 순서를 정한다. 그리고 실행 중인 메서드 내부에서 super 호출을 하면 다음 단계에 위치한 클래스나 트레이트의 메서드가 호출된다.
 * 선형화를 할 때 항상 맨 앞에는 구현한 클래스 자기 자신이 위치한다.
 * 믹스인이 되기 전까지는 상속 계층 안에서 taxablePolicy 트레이트의 위치가 결정되지 않고, 어떤 클래스에 믹스인할지에 따라 TaxablePolicy 트레이트의 위치는 동적으로 변한다.
 * 믹스인은 재사용 가능한 코드를 독립적으로 작성한 후 필요한 곳에서 쉽게 조합할 수 있게 해준다.
 * 클레스 폭발 문제의 단점은 클래스가 늘어나는게 아니라 클래스가 늘어날 수록 중복 코드도 함께 기하급수적으로 늘어난다는 점으로 믹스인에서는 발생하지 않는다.
 *
 * 쌓을 수 있는 변경
 * 믹스인은 상속 계층 안엥서 확장한 클래스보다 더 하위에 위치하게 된다. -> 대상 클래스의 자식 클래스처럼 사용될 용도로 만들어 졌다(따라서 믹스인을 추상 서브클래스라고 부르기도 한다.)
 * 믹스인을 사용하면 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가할 수 잇다 -> 쌓을 수 있는 변경
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
