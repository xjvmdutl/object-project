package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠트릴 수 있다.
 * 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만들며, 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성을 제거하는데 있다.
 *
 * 의존성 이해하기
 * 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
 * - 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
 * - 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
 * 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다.
 * 두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미하며, 의존성은 변경에 의한 영향을 전파 가능성을 암시한다.
 *
 * 의존성 전이
 * 의존성 전이가 의미하는 것은 PeriodCondition이 Screening에 의존할 경우 PeriodCondition은 Screening이 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것이다.
 * 의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니며, 전이될 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.
 * Screening이 내부 구현을 효과적으로 캡슐화하고 있다면 Screening에 의존하고 있는 PeriodCondition까지는 변경이 전파되지 않을 것이다.
 * -> 의존성 전이는 변경에 의해 영향이 널리 전파될 수도 있다는 경고일 뿐이다.
 * 의존성을 종류는 직접 의존성과 간접 의존성으로 나눈다.
 * - 직접 의존성: 한 요소가 다른 요소에 직접 의존하는 경우를 가리킨다, 의존성이 코드에 명시적으로 드러난다.
 * - 간접 의존성: 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다, 의존성이 코드안에 명시적으로 드러나지 않는다.
 * 결론적으로 의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다.
 *
 * 런타임 의존성과 컴파일타임 의존성
 * 런타임: 애플리케이션이 실행되는 시점
 * 컴파일 타임: 작성된 코드를 컴파일 하는 시점 or 코드 그 자체를 가리킨다.
 * -> 컴파일 타임 시점이 코드를 컴파일 하는 시점을 의미하는지 코드 그 자체를 가리키는지 파악하는 것이 중요하다.
 * 객체지향 애플리케이션에서 런타임의 주인공은 객체이다. -> 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다.
 * 코드 관점에서 주인공은 클래스이다. -> 컴파일타임 의존성이 다루는 주제는 클랫스 사이의 의존성이다.
 * 런타임 의존성과 컴파일 의존성은 다를 수 있다 -> 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야한다.
 * 유연하고 재사용 가능한 설계를 창조하기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.
 * 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안 된다. -> 실제 협력할 객체가 어떤 것인지는 런타임에 해결해야한다.
 * 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.
 *
 * 컨텍스트 독립성
 * 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합된다.
 * 구체 클래스에 대해 의존하는 것은 클래스의 인스턴스가 어떤 문맥에서 사용될 것인지를 구체적으로 명시하는 것과 같다.
 * 구체적인 문맥은 컴파일타임 의존성을 어떤 런타임의존성으로 대체하는냐에 따라 달라질 것이다.
 * 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다. -> 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용이 수월해지고 이를 컨텍스트 독립성이라 한다.
 * 설계가 유연해지기 위해서는 가능한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다.
 * -> 컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기 때문이다.(설계가 유연해지고 변경에 탄력적인 대응이 가능하다)
 *
 * 의존성 해결하기
 * 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다.
 * 1) 객체를 생성하는 시점에 생성자를 통해 의존성 해결
 * -> 객체를 생성하는 시점에 생성자에 의존 객체를 넣어 의존성을 해결 할 수 있다.
 * 2) 객체 생성 후 setter 메서드를 통해 의존성 해결
 * -> setter 메서드를 이용하는 방식은 객체 생성 이후 의존하고 있는 대상을 변경할 수 있는 가능성을 열어 놓고 싶은 경우에 유용하다.
 *    단, 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 떄문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다
 *    (setter 메서드를 통해 인스턴슬 변수를 설정하기 위해 내부적으로 해당 인스턴스 변수를 사용하는 코드를 실행하면 NullPointException이 발생한다, 시스템이 불안전하다)
 * -> 생성자 방식과 setter 방식을 혼합하면 이를 방지할 수 있다.
 *    항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후 필요에 따라 setter 메서드르 이용해 의존 대상을 변경할 수 있게 할 수 있다.
 *    (시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬수 있기 때문에 가장 선호되는 방법이다)
 * 3) 메서드 실행 시 인자를 이용해 의존성 해결
 * -> 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나, 메서드가 실행될 때마다 의존 대상이 매번 달라져야 하는 경우 유용하다.
 *    하지만 클랫스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다면 생성자를 이용하는 방식이나 setter 메서드를 이용해 의존성을 지속적으로 유지하는 방식으로 변경하는 것이 좋다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
