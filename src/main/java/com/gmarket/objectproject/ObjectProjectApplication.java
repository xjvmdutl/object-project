package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 변경 분리하기
 * 시간대별, 요일별, 구간별 방식의 공통점은 각 기본 정책을 구성하는 방식이 유사하다는 점이다.
 * - 기본 정책은 한 개 이상의 규칙으로 구성된다.
 * - 하나의 규칙은 적용조건과 단위요금의 조합이다.
 * 시간대별, 요일별, 구간별 방식은 하나 이상의 규칙들의 집합이라는 공통점을 가진다.
 * 시간대별, 요일별, 구간별 방식의 차이점은 각 기본 정책별로 요금을 계상하는 적용저건의 형식이 다르다는 것이다. 모든 규칙에 적용조건이 포함된다는 사실은 변하지 않지만 실제 조건의 세부적인 내용은 다르다.
 * 공통점은 변하지 않는 부분이다. 차이점은 변하는 부분이다. 우리의 목적은 변하지 않는 것과 변하는 것을 분리하는 것이라는 점을 기억하자. 따라서 변하지 않는 규칙으로부터 변하는 적용조건을 분리해야 한다.
 *
 * 변경 캡슐화하기
 * 협력을 일관성 있게 만들기 위해서는 변경을 캡슐화해서 파급효과를 줄여야한다.
 * 변경을 캡슐화하는 가장 좋은 방법은 변하지 않는 부분으로부터 변하는 부분을 분리하는 것이다. 물론 변하는 부분의 공통점을 잊어서는 안된다.
 * 이제 변하지 않는 부분이 오직 이 추상화에만 의존하도록 관계를 제한하면 변경을 캡슐화할 수 있게 된다.
 * 규칙(변하지 않는 것)으로 부터, 적용조건(변하는 것)을 분리해서 추상화한 후 시간대별, 요일별, 구간별 방식을 이 추상화의 서브타입으로 만든다. 이것이 서브타입 추상화다.
 * 그 후에 규칙이 적용조건을 표현하는 추상화를 합성 관계로 연결한다. 이것이 객체 캡슐화다.
 * 하나의 기본 정책은 하나 이상의 규칙들로 구성된다. -> 기본 정책을 표현하는 BasicRatePolicy는 FeeRule의 컬렉션을 포함한다.
 * FeeRule은 규칙을 구현하는 클래스며, 단위요금은 FeeRule의 인스턴스 변수인 feePerDuration에 저장돼 있다, FeeCondition은 적용조건을 구현하는 인터페이스이며, 변하는 부분을 캡슐화하는 추상화다.
 * 각 기본 정책별로 달라지는 부분은 각각의 서브타입으로 구현된다. -> TimeOfDayFeeCondition은 시간대별, DayOfDayFeeCondition은 요일별 방식, DurationFeeCondition은 구간별 방식을 구현한다.
 * FeeRule이 FeeCondition을 합성 관계로 연결하고 있는 점과 FeeRule이 오직 FeeCondition에만 의존하고 있다는 점을 주목하자 -> 변하는 FeeCondition의 서브타입은 변하지 않는 FeeRule로부터 캡슐화된다.
 * 변하지 않는 부분은 기본 정책이 여러 규칙들의 집합이며, 하나의 규칙은 적용조건과 단위요금으로 구성된다는 것이다. 이 관계는 BasicRatePolicy, FeeRule, FeeCondition의 조합으로 구현된다.
 * 변하는 부분은 적용조건의 세부적인 내용이다. 이것은 FeeCondition의 서브타입인 TimeOfDayFeeCondition, DayOfDayFeeCondition, DurationFeeCondition으로 구현된다.
 * 그리고 FeeRule은 추상화인 FeeCondition에 대해서만 의존하기 때문에 적용조건이 변하더라도 영향을 받지 않는다. 즉 적용조건이라는 변경에 대해 캡슐화돼 있다.
 *
 * 협력 패턴 설계하기
 * 변하지 않는 부분을 분리하고 변하는 부분을 적절히 추상화하고 나면 변하는 부분을 생략한 채 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기할 수 있다.
 * 추상화만으로 구성한 협력은 추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장할 수 있게 된다.-> 재사용 가능한 협력 패턴이 선명하게 드러난다.
 * - 변하지 않는 요소와 추상화만으로 표현된 모델
 * BasicRatePolicy -> FeeRule -> FeeCondition
 * - BasicRatePolicy와 FeeRule 사이의 협력
 * (fee = calculateFee(phone)) -> BasicRatePolicy (fee = calculateFee(call)) -> FeeRule
 * 객체지향에서는 모든 작업을 객체의 책임으로 생각하기 때문에 디 두 개의 책임을 객체에게 할당해야한다.
 * - 기본 정책의 요금 계산을 위한 추상적인 협력
 * (fee = calculateFee(phone)) -> BasicRatePolicy(fee = calculateFee(call)) -> FeeRule(intervals = findTimeIntervals(call)) -> FeeCondition
 *
 * 추상화 수준에서 협력 패턴 구현하기
 * 변하는 부분을 변하지 않는 부분으로부터 분리했기 때문에 변하지 않는 부분을 재사용할 수 있다. 그리고 새로운 기능을 추가하기 위해 오직 변하는 부분만 구현하면 되기 때문에 원하는 기능을 쉽게 완성할 수 있다.
 * -> 코드의 재사용성이 향상되고 테스트해야 하는 양이 감소한다. 기능을 추가할 떄 따라야 하는 구조를 강제할 수 있기 때문에 기능을 추가하거나 변경할 떄도 설계의 일관성이 무너지지 않는다.
 * 기본 정책을 추가하기 위해 규칙을 지키는 것보다 어기는 것이 더 어렵다는 점에 주목하라. 일관성 있는 협력은 개발자에게 확장 포인트를 강제하기 떄문에 정해진 구조를 우회하기 어렵게 만든다.
 * 개발자는 코드의 형태로 주어진 제약 안에 머물러야 하지만 작은 문제에 집중할 수 있는 자유를 얻는다. 그리고 이 작은 문제에 대한 해결책을 전체 문맥에 연결함으로써 협력을 확장하고 구체화할 수 있다.
 * 변경전의 설계는 전체적으로 일관성이 떨어지기 떄문에 코드에 대해 가지고 있던 기존의 지식이 유사한 기능을 이해하는 데 아무런 도움도 되지 않았다. -> 기존 코드에 대한 선입견이 이해에 걸림돌로 작용했다.
 * 협력을 일관성 있게 만들면 상황이 달라진다. 변하지 않는 부분은 모든 기본 정책에서 공통적이라는 것을 기억하자.
 * 이 공통 코드의 구조와 협력 패턴은 모든 기본 정책에 걸쳐 동일하기 때문에 코드를 한 번 이해하면 이 지식을 다른 코드를 이해하는 데 그대로 적용할 수 있다.
 * 일단 일관성 있는 협력을 이해하고 나면 변하는 부분만 따로 떼어내어 독립적으로 이해하더라도 전체적인 구조를 쉽게 이해할 수 있다.
 * 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 가장 효과적인 방법이다. 개념적 무결성을 일관성과 동일한 뜻으로 간주해도 무방하다.
 * 시스템이 일관성 있는 몇개의 협력 패턴으로 구성된다면, 시스템을 이해하고 수정하고 확장하는 데 필요한 노력과 시간을 아낄 수 있다.
 * 따라서 협력을 설계하고 있다면 항상 기존의 협력 패턴을 따를 수는 없는지 고민하라. 그것이 시스템의 개념적 무결성을 지키는 최선을 방법일 것이다.
 * - 개념적 무결성이 시스템 설계에서 가장 중요하다고 주장한다.
 * - 좋은 기능들이긴 하지만 서로 독립적이고 조화되지 못한 아이디어들을 담고 있는 시스템보다는 여러 가지 다양한 기능이나 갱신된 내용은 빠졌더라도 하나로 통합된 일련의 설계 아이디어를 반영하는 시스템이 훨씬 좋다.
 *
 * 지속적으로 개선하라
 * - 처음에는 일관성을 유지하는 것처럼 보이던 협력 패턴이 시간이 흐르면서 새로운 요구사항이 추가되는 과정에서 일관성의 벽에 조금씩 금이 가는 경우를 자주 보게 된다.
 * - 협력을 설계하는 초기단계에서 모든 요구사항을 예측할 수 없기에 이는 자연스러운 현상이며, 오히려 새로운 요구사항을 수용할 수 있는 협력 패턴을 향해 설계를 진화시킬 수 있는 좋은 신호로 받아들여야한다.
 * - 협력은 고정된 것이 아니다. 만약 현재의 협력 패턴이 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리펙토링해라
 * - 요구사항의 변경에 따라 협력 역시 지속적으로 개선해야 한다. 중요한 것은 현재의 설계에 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰 지속적으로 코드를 개선하려는 의지다.
 *
 * 패턴을 찾아라
 * 일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것이다. 변경을 캡슐화하는 방법이 협력에 참여하는 객체들의 역할과 책임을 결정하고 이렇게 결정된 협력이 코드의 구조를 결정한다.
 * -> 변경의 방향을 파악할 수 있는 날카로운 감각을 길러라. 이 변경에 탄력적으로 대응할 수 있는 다양한 캡슐화 방법과 설계 방법을 익히는 것 역시 중요하다.
 * 애플리케이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화 할 수 있는 적절한 추상화를 찾은 후 이 추상화에 변하지 않는 공통적인 책임을 할당하라
 * 현재의 구조가 변경을 캡슐화하기 적합하지 않다면 코드를 수정하지 않고도 원하는 변경을 수용할 수 있도록 협력과 코드를 리펙토링해라. 변경을 수용할 수 있는 적절한 역할과 책임을 찾다보면 협력의 일관성이 서서히 윤곽을 드러낼 것이다.
 * 협력을 일관성 있게 만든다는 것은 유사한 변경을 수용할 수 있는 협력 패턴을 발견하는 것과 동일하다.
 * - 객체지향 설계는 객체의 행동과 그것을 지원하기 위한 구조를 계속 수정해 나가는 작업을 반복해 나가면서 다듬어진다. -> 객체, 역할, 책임은 계속 진화해 나가는 것이다.
 * - 협력자들 간에 부하를 좀 더 균형 있게 배분하는 방법을 새로 만들어내면 나눠줄 책임이 바뀌게 된다.(만약 객체들이 서로 통신하는 방법을 개선해냈다면 이들간의 상호작용은 재정의되어야 한다.)
 * - 이 같은 과정을 거치면서 객체들이 자주 통신하는 경로는 더욱 효과적이게 되고, 주어진 작업을 수행하는 표준 방안이 정착된다 -> 협력 패턴이 드러난다.
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
