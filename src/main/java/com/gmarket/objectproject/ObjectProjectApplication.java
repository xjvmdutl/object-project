package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 계약에 의한 설계라고 부른다.
 * - 사전 조건: 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건.
 * - 사후 조건: 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 조건
 * - 클래스 불변식: 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 클래스 불변식
 * 위 3가지 조건에 따라 계약에 의한 설계는 구성된다.
 * 계약에 의한 설계를 사용하면 리스코프 치환 원칙이 강제하는 조건을 계약의 개념을 이용해 좀 더 명확하게 설명할 수 있다.
 * 리스코프 치환 원칙과 계약에 의한 설계 사이의 관계: 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야한다.
 * 계약에 의한 설계에 따르면 협력하는 클라이언트와 슈퍼타입의 인스턴스 사이에는 어떤 계약이 맺어져 있다. 클라이언트와 슈퍼타입은 이 계약을 준수할 때만 정상적으로 협력할 수 있다.
 * 클라이언트 입장에서 서브타입은 정말 슈퍼타입의 한 종류여야 하는 것이다.
 * 어떤 클래스가 다른 클래스를 상속받으면, 그 클래스의 자식 클래스 또는 서브클래스가 되지만 모든 서브클래스가 서브타입인 것은 아니다. 코드 재사용을 위해 상속을 사용했다면, 그리고 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 없다면 서브타입이라고 할 수 없다.
 * 서브타입이 슈퍼타입처럼 보일 수 있는 유일한 방법은 클라이언트가 슈퍼타입과 맺은 계약을 서브타입이 준수하는 것뿐이다.
 *
 * 서브타입과 계약
 * 계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있다는 것이다.
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
