package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 리스코프에 의하면 상속 관계로 연결한 두 클래스가 서브 타이핑 관계를 만족시키기 위해서는 아래 조건을 만족시켜야한다.
 * - S형의 각 객체 o1에 대해 T형의 객체 o2가 하나 있고, T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때 P의 동작이 변하지 않으면 S는 T의 서브타입이다.
 * 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다. => 클라이언트가 차이점을 인식하지 못한 채 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
 * 리스코프 치환 원칙에 따르면 자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브타이핑이라고 불러야한다.
 * Stack - Vector는 리스코프 치환 원칙을 위반하는 전형적인 예로, 클라이언트가 부모 클래스인 Vector에 대해 기대하는 행동을 Stack에 대해서는 기대할 수 없기 때문에 행동 호환성을 만족시키지 않기 떄문이다.
 *
 * 클라이언트와 대체 가능성
 * Square가 Rectangle을 대체할 수 없는 이유는 클라이언트의 관점에서 Square와 Rectangle이 다르기 때문으로, 클라이언트 입장에서 정사각형을 추상화한 Square는 직사각형을 추상화한 Rectangle과 동일하지 않다.
 * Rectangle을 사용하는 클라이언트는 Rectangle의 너비와 높이가 다를 수 있다는 가정하에 코드를 개발한다. 반면 Square는 너비와 높이가 항상 같다.
 * 너비와 높이가 다르다는 가정하에 개발된 클라이언트 코드에서 Rectangle을 Square로 대체할 경우 Rectangle에 대해 세워진 가정을 위반할 확률이 높다.
 * 결구 코드는 예상한 대로 작동하지 않으며 개발자는 밤을 새워 디버깅해야 하는 악몽과도 같은 상황에 빠져 버리고 말것이다.
 * 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트 가정을 준수해야 한다는 것을 강조한다.
 * Stack과 Vector가 서브타이핑 관계가 아니라 서브클래싱 관계인 이유도 마찬가지로 해당 예가 리스코프 치환 원칙을 위반하는 가장 큰 이유는 상속으로 인해 Stack에 포함돼서는 안 되는 Vector의 퍼블릭 인터페이스가 Stack의 퍼블릭 인터페이스에 포함됬기 때문이다.
 * Stack과 협력하는 클라이언트와 Vector와 협력하는 클라이언트는 Stack과 vector 각각에 대해 전송할 수 있는 메시지와 기대하는 행동이 서로 다르다.
 * 리스코프 치환 원칙은 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다라는 결론을 이끌고 어떤 모델의 유효성은 클라이언트의 관점에서만 검증 가능하다는 결론을 이끈다.
 * 일단 클라이언트와의 협력 관계 속으로 모델을 밀어넣는 순간 지금까지 올바르다고 생각했던 서브타입이 올바르지 않다는 사실을 깨닫게 될 것이다.
 * 리스코프 치환 원칙은 상속 관계에 있는 두 클래스 사이의 관계를 클라이언트와 떨어트려 놓고 판단하지 말라고 속삭인다. 상속 관계는 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바르다.
 * 대체 가능성을 결정하는 것은 클라이언트다.
 *
 * is-a 관계 다시 살펴보기
 * 클라이언트 관점에서 자식 클래스의 행동이 부모 크랠스의 행동과 호환되지 않고 그로 인해 대체가 불가능하다면 어휘적으로 is-a라고 말할 수 있다고 하더라도 그 관계를 is-a 관계라고 할 수 없다.
 * is-a 는 클라이언트 관점에서 is-a 일 때만 참이다.
 * is-a 관계로 표현된 문장을 볼 때마다 문장 앞에 "클라이언트 입장에서" 라는 말이 빠져 있다고 생각하라. 클라이언트를 배제한 is-a 관계는 여러분을 혼란으로 몰아갈 가능성이 높다.
 * is-a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다. 일반적으로 클라이언트를 고려하지 않은 채 개념과 속성의 측면에서 상속 관계를 정할 경우 리스코프 치환 원칙을 위반하는 서브클래싱에 이르게 될 확률이 높다.
 * 오더스키가 설명한 is-a 관계를 행동이 호환되는 타입에 어떤 이름을 붙여야 하는지를 설명하는 가이드라고 생각하는 것이 좋다. 슈퍼타입과 서브타입이 클라이언트 입장에서 행동이 호환된다면, 두 타입을 is-a로 연결해 문장을 만들어도 어색하지 않은 단어로 타입의 이름을 정하라는 것이다.
 * 행동을 고려하지 않은 두 타입의 이름이 단순히 is-a로 연결 가능하다고 해서 상속 관계로 연결하지마라. 결론적으로 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다
 *
 * 리스코프 치환 원칙은 유연한 설게의 기반이다.
 * 리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.
 * 새로운 자식 클래스를 추가하더라도 클라이언트의 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다.
 * 클라이언트의 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다는 것이다.
 * 리스코프 치환 원칙을 따르는 설계는 유연할 뿐만 아니라 확장성이 높다.
 * 이전에 설계한 OverlappedDiscountPolicy는 의존성 역전 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙이 한데 어울러진 설계다.
 * - 의존성 역전 원칙: 구체 클래스인 Movie와 OverlappedDiscountPolicy 모두 추상 클래스인 DiscountPolicy에 의존한다. 상위 수준의 모듈인 Movie와 하위 수준의 모듈인 OverlappedDiscountPolicy는 모두 추상 클래스인 DiscountPolicy에 의존한다.
 * - 리스코프 치환 원칙: DiscountPolicy와 협력하는 Movie의 관점에서 DiscountPolicy 대신 OverlappedDiscountPolicy와 협력하더라도 아무런 문제가 없다. OverlappedDiscountPolicy는 클라이언트에 대한 영향 없이 DiscountPolicy를 대체할 수 있다.
 * - 개방-폐쇄의 원칙: 중복 할인 정책이라는 새로운 기능을 추가하기 위해 DiscountPolicy의 자식 클래스인 OverlappedDiscountPolicy를 추가하더라도 Movie에는 영향을 끼치지 않는다. 기능 확장을 하면서 기존 코드를 수정할 필요는 없다.
 * 자식 클래스가 클라이언트의 관점에서 부모 클래스를 대체할 수 있다면 기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다.
 * 따라서 리스코프 치환 원칙은 개방-폐쇄의 원칙을 만족하는 설계의 전제 조건이며, 일반적으로 리스코프 치환 원칙 위반은 잠재적인 개방-폐쇄 원칙 위반이다.
 *
 * 타입 계층과 리스코프 치환 원칙
 * 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나일 뿐이다. 자바,C#의 인터페이스나 스칼라의 트레이드 등 기법을 사용하면 클래스 사이의 상속을 사용하지 않고 서브타이핑 관계를 구현할 수 있다.
 * 이런 기법을 사용하는 경우에도 리스코프 치환 원칙을 준수해야만 서브타이핑 관계라고 말할 수 있다. 구현 방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용돼야 한다
 * 리스코프 치환 원칙을 위반하는 예로 상속을 사용하는 이유는 대부분의 객체지향 언어가 구현 단위로서 클래스를 사용하고, 코드 재사용의 목적으로 상속을 지나치게 남용하는 경우가 많기 떄문이다.
 * 상속이 아닌 다른 방법을 이용하더라도 클라이언트의 관점에서 서로 다른 구성 요소를 다뤄야 한다면 서브타이핑 관계의 제약을 고려해서 리스코프 치환 원칙을 준수해야 한다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
