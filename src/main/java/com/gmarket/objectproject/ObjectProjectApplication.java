package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것이다 -> 대부분 입문자들은 전체 개발 활동의 중심에 클래스를 놓는다.
 * 클래스라는 구현 도구에 지나치게 집착하면 경직되고 유연하지 못한 설계를 이를 확률이 높아진다.
 * 훌룡한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다. -> 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야한다.
 * 책임이 객체가 수신할 수 있는 메시지의 기반이 된다.-> 애플리케이션은 클래스로 구성되지만, 메시지를 통해 정의된다는 사실을 기억하라
 * 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다 -> 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는데 도움이 되는 설계원칙과 기법을 익히고 적용해야 한다.
 *
 * 클라이언트 서버 모델델
 * 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다. 메시지는 객체사이의 협력을 가능하게 하는 매개체다.
 * 메시지를 매개로 하는 요청과 응답의 조합이 두 객체사이의 협력을 구성한다.
 * 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버 모델이다.
 * 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부르며, 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다
 * 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적아. -> 협력의 관점에서 객체는 두가지 종류 메시지의 집학도 함께 고려하는 것이 바람직하다.
 * 협력의 관점에서 객체는 객체가 수신하는 메시지 집합,외부의 객체에게 전송하는 메시지의 집합이 존재한다. -> 수신하는 메시지 집합만 고민하지 말고, 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직한다
 * 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야한다. 두 객체 사이의 협력을 가능하게 해주는 메게체가 메시지다.
 *
 * 메시지와 메시지 전송
 * 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
 * 메시지 전송(메시지 패싱): 한 객체가 다른 객체에게 도움을 요청하는 것
 * 메시지 전송자: 메시지를 전송하는 객체
 * 메시지 수신자: 메시지를 수신하는 객체
 * 메시지는 오퍼레이션 명과 인자로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.\
 *
 * 메시지와 메서드
 * 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려있다.
 * 메시지를 수신했을 때 실제 실행되는 함수 또는 프로시저를 메서드라고 한다 -> 코드상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라지 수 있다.
 * 전통적인 방식은 코드의 의미와 컴파일 시점을 의미와 같지만, 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
 * 메시지 전송을 코드 상에 표기하는 시점에는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다. -> 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라 믿을 수 밖에 없다.
 * 메시지와 메서드의 구분은  메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다.
 * - 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면된다.
 * - 메시지 수신자 역시 누가 메시지를 전송하는지 알 필요 없이 도착했다는 사실만 알면 된다.
 *
 * 퍼블릭 인터페이스와 오퍼레이션
 * 객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다. -> 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.
 * 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다.
 * 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부르고, 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다.
 * 흔히 오퍼레이션이라 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.(인터페이스의 isSatisfiedBy)
 * 메시지를 수신했을때 실제로 실행되는 코드는 메서드라고 부른다.(구현 클래스의 isSatisfiedBy들)
 * 프로그래밍 언어의 관점에선 객체가 다른 객체에게 메시지를 전송하면, 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석해, 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.
 *
 * 시그니처
 * 오퍼레이션의 오버에레이션 이름과 파라미터 목록을 합쳐 시그니쳐라고 한다.
 * 메시지: 객체가 다른 객체와 혐력하기 위해 추상적인 클래스이다.
 * 메서드: 응답하기 위해 실행되는 코드
 * 퍼블릭인터페이스: 외부에서 수신할 수있는 메시지 묶음 클래스의
 * 시그니처: 오커레이션이나 메서드를 나타낸 것으로 이름과 인자 목록을 포함한다
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
