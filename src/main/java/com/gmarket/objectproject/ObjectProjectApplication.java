package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 타입은 객체들의 집합이기 떄문에 다른 타입을 포함하는 것이 가능하다. 타입 안에 포함된 객체들을 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 새로운 타입은 자연스럽게 기존 타입의 부분집합이 된다.
 * 타입은 집합의 관점에서 더 세분화된 타입의 집합을 부분집합으로 포함할 수 있다. -> 타입이 다른 타입에 포함될 수 있기 때문에 동일한 인스턴스가 하나 이상의 타입으로 분류되는 것도 가능하다.
 * 다른 타입을 포함하는 타입은 포함되는 타입보다 좀 더 일반화된 의미를 표현할 수 있다. 반면 포함되는 타입은 좀 더 특수하고 구체적이다.
 * 다른 타입을 포함하는 타입은 포함되는 타입보다 더 많은 인스턴스를 가진다. -> 포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 일반적이고, 포함되는 타입은 외연 관점에서 더 작고 내연 관점에서 더 특수하다.
 * 이것은 포함 관계로 연결된 타입 사이에 개념적으로 일반화와 특수화 관계가 존재한다는 것을 의미한다.
 * 타입 계층을 표현할 때는 더 일반적인 타입을 위쪽에 더 특수한 타입을 아래쪽에 배치하는 것이 관례다.
 * 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입, 더 특수한 타입을 서브타입이라고 부른다.
 * 객체의 정의를 의미하는 내연 관점에서 일반화란 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정을 의미하며, 반대로 특수화란 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정을 의미한다.
 * 내연을 관점에서 특수한 타입의 정의는 일반적인 타입의 정의를 좀 더 구체화한 것이다.
 * 집합을 의미하는 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋이다. 반대로 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋이다.
 * 따라서 특수한 타입에 속한 인스턴스는 동시에 더 일반적인 타입의 인스턴스이기도 하다.
 * 일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행우의 결과를 가리킨다.
 * 특수화는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
 * 내연의 관점에서 서브타입의 정의가 슈퍼타입의 정의보다 더 구체적이고 외연의 관점에서 서브타입에 속하는 객체들의 집합이 슈퍼타입에 속하는 객체들의 집합에 포함된다는 사실을 알 수 있다.
 * 슈퍼 타입: 집합이 다른 집합의 모든 맴버를 포함한다, 타입 정의가 다른 타입보다 좀 더 일반적이다.
 * 서브 타입: 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다, 타입 정의가 다른 타입보다 좀 더 구체적이다.
 *
 * 객체지향 프로그래밍과 타입 계층
 * 일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
 * 특수한 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
 * 퍼블릭 인터페이스 관점에서의 슈퍼타입과 서브타입
 * - 슈퍼타입이란 서브 타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.
 * - 서브타입이란 슈퍼 타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.
 * 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입이다.
 * 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
