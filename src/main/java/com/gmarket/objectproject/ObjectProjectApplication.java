package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 설계는 트레이드오프의 산물이다 -> 설계를 적절하게 트레이드오프 할 수 있는 능력이 숙력자와 초보자를 구분하는 가장 중요한 기준이라고 할 수 있다.
 * 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라 -> 원칙을 아는것보다 더 중요한건 언제 원칙이 유용하고 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다.
 *
 * 디미터 법칙은 하느의 도트를 강제하는 규칙이 아니다.
 * 디미터 법칙은 "오직 하나의 도트만을 사용하라"라는 말로 요약되기도 한다
 * 이를 위배하는 예로 IntStream 을 든다(IntStream.of(1, 2, 3, 4).filter(x -> x < 3).distinct().count())
 * => of, filter, distinct 메서드 모두 IntStream이라는 동일한 클래스의 인스턴스를 반환하기 디미트 법칙을 위배하는것이 아니다.
 * => IntStream 인스턴스를 또다른 IntStream 인스턴스로 변환하는 것 뿐이다.
 * 디미티 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정한다.
 * 하나 이상의 도트르 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다. -> 기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면, 그것은 디미터 법칙을 준수한 것이다.
 * 이 메서드는 객체 내부에 대한 어떤 내용도 묻지 않으므로 "묻지 말고 시켜라" 원칙을 위반하지 않는다.
 *
 * 결합도와 응집도의 충돌
 * 일반적으로 어떤 객체의 상태를 물어본 후 반환된 상태를 기반으로 결정을 내리고 그 결정에 따라 객체의 상태를 변겨하는 코드는 "묻지 말고 시켜라" 스타일로 변경해야 한다.
 * 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법이다.
 * "묻지 말고 시켜라"와 "디미터 법칙"을 준수하는 것이 항상 긍정적인 결과로 귀결되는 것은 아니다.
 * -> 모든 상황에서 맹목적으로 위임 메서드를 추가하면, 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 되고, 결국 객체는 상관 없는 책임들을 한꺼번에 떠안기 떄문에 응집도가 낮아진다.
 * -> 클래스는 하나의 변경 원인만을 가져야 하며, 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며, 작은 변경으로도 쉽게 무너질 수 있다.
 * 영화 예매 시스템의 PeriodCondition 클래스의 isSatisfiedBy 메서드는 Screening의 내부 상태를 가지고 오기 때문에 캡슐화를 위반하는 것처럼 보일 수 있다.
 * -> 해당 메서드를 Screening 으로 옮기게 된다면?? Screening이 기간에 따른 할인 조건을 판단한느 책임을 떠안게 된다. -> Screening이 직접 할인 조건을 판단하게 되면 객체의 응집도가 낮아진다.
 * 결국 Screening의 캡슐화를 향상시키는 것보다 Screening의 응집도를 높이고 Screening과 PeriodCondition 사이의 결합도를 낮추는 것이 전체적인 관점에서 더 좋은 방법이다.
 * 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료구조인지에 따라 달려있다고 한다.
 * -> 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.
 * 결국 소프트웨어 설계에 법칙이란 존재하지 않느다. 원칙을 맹신하지 마라!!! 설계는 트레이드 오프의 산물이다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
