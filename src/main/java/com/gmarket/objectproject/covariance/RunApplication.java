package com.gmarket.objectproject.covariance;

public class RunApplication {

  public static void main(String[] args) {
    new Customer().order(new BookStall());
    new Customer().order(new MagazineStore()); //MagazineStore는 BookStall의 서브 타입으로 BookStall 대신 협력할 수 있다.
    /**
     * 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 부모 클래스에서 선언한 반환타입의 서브타입으로 지정할 수 있는 특성을 리턴 타입 공변성이라 한다.
     * 서브타입에서 메서드의 사후조건이 강화되더라도 클라이언트 입장에서는 영향이 없다.
     * -> 리턴 타입 공변성은 계약에 의한 설계 관점에서 계약을 위반하지 않는다.
     * 자바는 리턴타입공변성을 지원하지만 C#은 리턴 타입 공변성을 지원하지 않는다.
     * Book 타입을 반환하는 BookStall의 sell 메서드는 magazine 타입을 반환하는 magazineStore의 sell 메서드와는 아무런 상관이 없다.
     * -> 타입 사이에 어떤 관계도 없는 것을 무공변성이라고 한다.
     * 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라밑커 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있는 특성을 파라미터 타입 반공변성이라고 한다.
     * -> 메서드를 정의한 클래스의 타입 계층과 파라미터의 타입계층의 방향이 반대인 경우 서브타입 관계를 만족한다는 것을 의미
     * 서브타입에서 메서드의 사전조건이 약화되더라도 클라이언트 입장에서는 영향이 없다.
     * -> 파라미터 타입 반공변성은 계약에 의한 설계 관점에서 계약을 위반하지 않는다.
     * 자바는 파라미터 반공변성을 지원하지 않는다.
     * 서브타입은 슈퍼타입에서 정의한 것보다 더 강력한 사전조건을 정의할 수 없지만 사전조건을 완화할 수는 있다.
     * 사전조건은 파라미터에 대한 제약조건이므로 슈퍼타입에서 정의한 파라미터 타입에 대한 제약을 좀 더 완화할 수 있다 -> 좀더 완화된 슈퍼타입을 파라미터로 받을 수 있다.
     * 리턴타입은 사후조건과 관련이 있으며 서브타입은 슈퍼타입에서 정의된 사후조건을 완화시킬 수는 없지만 강화할 수는 있다 -> 슈퍼타입에서 정의한 리턴 타입보다 더 강화된 서브타입 인스턴스를 반환하는 것이 가능하다.
     * 이름없는 메서드를 정의하는 것을 허용하는 언어들은 객체의 타입뿐만 아니라 메서드의 타입을 정의할 수 있게 허락한다. 그리고 타입에서 정의한 시그니처를 준수하는 메서드들을 이 타입의 인스턴스로 간주한다.
     * -> sell 메서드와 이 메서드의 익명함수 형태의 경우 파라미터 타입과 리턴 타입이 동일하기 때문에 모두 같은 타입의 인스턴스다.
     * 함수타입의 서브타입을 정의할 수 있을까? 정의할 수 있다면 서브타입 메서드가 슈퍼타입 메서드를 대체할 수 있을까??
     * -> 가능하다. 파라미터 타입이 반공변성을 가지고 리턴 타입이 공변성을 가질 경우 메서드가 오버라이드 가능하다는 것을 알면 오버라이드가 가능하다는 것은 메서드 대체가 가능하며, 두 메서드 사이에 서브타이핑 관계가 존재한다는 것을 의미한다.
     * 서브타입 관계를 구현하는 방식은 언어에 따라 다르므로 우리가 사용하는 언어가 함수 타입에 관한 서브타입 관계를 준수하는지 확인해야한다.
     *
     */
  }
}
