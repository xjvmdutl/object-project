package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다.
 * 어떤 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스이다.
 * 그러나 이런 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 될 것이다.
 * 의존성은 변경의 전파와 관련된 것이기 때문에 설계는 변경의 영향을 최소화하도록 의존성을 관리해야 한다.
 * 상위 수준 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안되는 것이다.
 * 대부분의 경우 우리가 재사용하려는 대상은 상위 수준의 클래스라는 점을 기억해라
 * -> 상위 수준의 클래스가 하위 수준의 클래스에 의존하면 상위 수준의 클래스를 재사용할때  하위 수준의 클래스도 필요하기 때문에 재사용하기가 어려워진다.
 * 중요한것은 사위 수준의 클래스로 Movie와 AmountDiscountPolicy 모두가 추상화에 의존하도록 수정하면 하위 수준 클래스의 변경으로 인해 상위 수준의 클래스가 영향을 받는것을 방지할 수 있다.
 * 또한 상위 수준을 재사용할 때 하위 수준의 클래스에 얽매이지 않고도 다양한 컨텍스트에서 재사용이 가능하다.
 * 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.
 * 정리
 * - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야한다.
 * - 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.
 * 이를 의존성 역전 원칙이라고 부르며 이를 따르는 설계는 의존성의 방향이 전통적인 절차형 프로그래밍과는 반대 방향으로 나타나기 떄문에 이렇게 부른다.
 *
 * 의존성 역전 원칙과 패키지
 * 역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용이 된다.
 * 전통적인 모듈 구조
 * Movie / DiscountPolicy, AmountDiscountPolicy, PercentDiscountPolicy
 * 해당 구조는 개방-폐쇄 원칙도 준수하고 의존성 역전 원칙도 따르기 때문에 이설계는 재사용이 가능하다고 생각이되지만 그렇지 않다.
 * Movie를 다양한 컨텍스트에서 재사용하기 위해서는 불필요한 클래스들이 Movie와 함께 배포되어야만 하기 때문이다.
 * Movie가 DiscountPolicy에 의존하고 있기 떄문에 Movie를 정상적으로 컴파일하기 위해서는 DiscountPolicy 클래스가 필요하다.
 * -> 코드의 컴파일이 성공하기 위해 함께 존재해야 하는 코드를 정의하는 것이 바로 컴파일타임 의존성이다. 문제는 DiscountPolicy가 포함돼 있는 패키지안에 AmountDiscountPolicy, PercentDiscountPolicy 클래스가 포함돼 있다는 것이다.
 * c++ 같은 언어에서는 같은 패키지 안에 존재하는 불필요한 클래스들로 인해 빈번한 재컴파일과 재배포가 발생할 수 있다.
 * 의존성의 정의에 따라 Movie는 DiscountPolicy를 수정하지 않을 경우에는 영향을 받지 말아야한다.
 * 하지만 이는 코드 수정에 있어서는 사실이지만 컴파일 측면에서는 사실이 아니다 -> DiscountPolicy가 포함된 패키지 안의 어떤 클래스가 수정되더라도 패키지 전체가 재배포돼야 한다.
 * 이로 인해 이 패키지에 의존하는 movie 클래스가 포함된 패키지 역시 재컴파일돼야 하며, movie에 의존하는 또다른 패키지가 있다면 컴파일은 의존성의 그래프를 타고 애플리케이션 코드 전체로 번져갈 것이다.
 * 따라서 불필요한 클래스들을 같은 패키지에 두는 것은 전체적인 빌드 시간을 가파르게 상승시킨다.
 * 인터페이스의 소유권을 역전시킨 객체지향적인 모듈 구조
 * Movie, DiscountPolicy / AmountDiscountPolicy, PercentDiscountPolicy
 * 따라서 위와 같이 추상화를 별도의 독립적인 패키지가 아닌 클라이언트가 속한 패키지에 포함시켜야 한다, 그리고 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야한다(Separated Interface 패턴)
 * Movie와 추상 클래스인 DiscountPolicy를 하나의 패키지로 모으는 것은 Movie를 특정한 컨텍스트로부터 완벽하게 독립시킨다. -> 새로운 할인 정책을 위해 새로운 패키지를 추가하고 새로운 DiscountPolicy의 자식 클래스만 구현하면 상위 수준의 협력 관계를 재사용할 수 있다.
 * 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야한다.
 * 전통적인 설계 패러다임은 인터페이스의 소유권을 클라이언트 모듈이 아닌 서버 모듈에 위치시키는 반면 잘 설계된 객체지향 애플리케이션에서는 인터페이스의 소유권을 서버가 아닌 클라이언트에 위치시킨다.
 * 정리하면 유연하고 재사용 가능하며 컨텍스트에 독립적인 설계는 전통적인 패러다임이 고수하는 의존성의 방향을 역전시킨다.
 * 전통적인 패러다임에서는 상위 수준 모듈이 하위 수준 모듈에 의존했다면 객체지향 패러다임에서는 상위 수준 모듈과 하위 수준 모듈이 모두 추상화에 의존한다.
 * 전통적인 패러다임에서는 인터페이스가 하위 수준 모듈에 속했다면 객체지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
