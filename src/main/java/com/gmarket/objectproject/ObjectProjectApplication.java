package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 믹스인은 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스다.
 * 믹스인을 사용하는 목적은 다양한 객체 구현 안에서 동일한 행동을 중복 코드 없이 재사용할 수 있게 만드는 것이다.
 * 공통의 행동이 믹스인된 객체들은 동일한 메시지를 수신할 수 있는 퍼블릭 인터페이스를 공유하게 되는 것이다.
 * 스칼라의 트레이트로 믹스인을 구현해보자.
 * 스칼라는 비교와 관련된 공통적인 구현을 믹스이해서 재사용할 수 있게 Ordered라는 트레이트를 제공한다. Ordered 트레이트는 내부적으로 추상 메서드 compare를 사용해 <,>,<=, >= 연산자를 구현한다.
 * 비교 연산자를 추가하고 싶은 클래스에 Ordered 트레이트를 믹스인하고 추상 메서드 compare를 오버라이딩하기만 하면 꽁짜로 <,>,<=, >= 연산자를 퍼블릭 인터페이스에 추가할 수 있게 된다.
 * Ordered 트레이트는 구현뿐만 아니라 퍼블릭 메서드를 퍼블릭 인터페이스에 추가하기 때문에 Money는 Ordered 트레이트를 요구하는 모든 위치에서 Ordered를 대체할 수 있다.
 * -> 서브타입의 요건인 리스코프 치환 원칙을 만족시키기 때문에 Money는 Ordered 타입으로 분류될 수 있다.
 * Ordered 트레이트를 믹스인하고 추상 메서드 compare를 구현하는 순간 Money의 퍼블릭 인터페이스 안에는 <,>,<=, >= 라는 다수의 연산자가 자동으로 추가된다.(Money의 인터페이스는 더 많은 연산자로 인해 풍부해졋다)
 * 믹스인은 간결한 인터페이스를 가진 클래스를 풍부한 인터페이스를 가진 클래스로 만들기 위해 사용할 수 있다. 풍부한 인터페이스를 정의한 트레이트의 서브타입으로 해당 클래스를 만드는 부수적인 효과도 얻으면서 말이다
 * - 간결한 인터페이스를 풍부한 인터페이스로 만들 때 트레이트를 사용할 수 있다.
 * 자바 8에 새롭게 추가된 디폴트 메서드는 인터페이스에 메서드의 기본 구현을 추가하는 것을 허용한다. 인터페이스에 디폴트 메서드가 구현돼 있다면 이 인터페이스를 구현하는 클래스는 기본 구현을 가지고 있는 메서드를 구현할 필요가 없다.
 * 디폴트 메서드를 사용하면 추상 클래스가 제공하는 코드 재사용성이라는 해택을 그대로 누리면서도 특정한 상속 계층에 얽매이지 않는 인터페이스의 장점을 유지할 수 있다.
 * 자바의 경우에는 믹스인을 구현하기 위해 디폴트 메서드를 사용할 수 있으며, 이를 통해 간결한 인터페이스를 가진 클래스를 풍부한 인터페이스를 가진 클래스로 변경할 수 있다.
 * 하지만 디폴트 메서드가 제공하는 혜택을 누리면서 설게를 견고하게 유지하기 위해서는 디폴트 메서드가 가지는 한계를 분명하게 인식하는 것이 중요하다.
 * -> getConditions와 getDiscountAmount 오퍼레이션이 인터페이스에 추가가 되는된다.
 * -> 디폴트 메서드인 calculateDiscountAmount 메서드가 내부적으로 두 개의 메서드를 사용하기 때문에 이 인터페이스를 구현하는 모든 클래스들은 해당 메서드의 구현을 제공해야 한다는 것을 명시한 것이다.
 * 이 메서드들이 인터페이스에 정의돼 있기 때문에 클래스 안에서 퍼블릭 메서드로 구현돼야 한다는 것이 문제이다.(추상 클래스일 경우에는 protected였다)
 * 이것은 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가하는 결과를 낳게 된다.
 * -> 심지어 클래스 내부에서 DiscountConditions의 목록을 관리한다는 사실을 외부에 공개할 뿐 아니라 public으로 메서드를 제공함으로써 이 목록에 접근할 수 있게 한다 -> 캡슐화를 약화
 * 디폴트 메서드를 사용해 추상 클래스를 대체할 경우 인터페이스가 불필요하게 비대해지고 캡슐화가 약화될 수도 있다는 사실을 인지하자
 * 또한 이 방법은 AmountDiscountPolicy, PercentDiscountPolicy 클래스 사이의 코드 중복을 완벽하게 제거해 주지도 못한다.
 * 자바 8에 디폴트 메서드르르 추가한 이유가 인터페이스로 추상 클래스의 역할을 대체하려는 것이 아니기 떄문이다.
 * -> 기존에 널리 사용되고 있는 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 하위 호환성 문제를 해결하기 위해 나온 것이지 추상 클래스를 제거하기 위한 것이 아니다.
 * 따라서 타입을 정의하기 위해 디폴트 메서드를 사용할 생각이라면 그 한계를 명확하게 알아두고 사용하자
 * - 인터페이스에 새로운 메서드를 추가하는 등 변경이 필요할때 이전에 해당 인터페이스를 구현했던 모든 클래스의 구현도 바꿔야한다.
 * - 자바 8에서는 2기본 구현을 포함하는 인터페이스를 정의하는 2가지 방법을 제공하는데
 * - 첫번째는 인터페이스 내부에 정적메서드를 사용하는 것이다.
 * - 두번째는 인터페이스의 기본 구현을 제공할 수 있게 디폴트 메서드라는 기능을 사용하는 것이다.
 * - 결과적으로 기존 인터페이스를 구현하는 클래스는 자동으로 인터페이스에 추가된 새로운 메서드의 디폴트 메서드를 상속받게 된다.
 * 타입을 정의하는 기준은 객체가 외부에 제공하는 퍼블릭 인터페이스이기 때문에 실제로 타입의 개념을 코드로 옮길 수 있는 다양한 방법이 존재하며 동시에 타입의 구현 방법만큼이나 다양한 방식으로 타입 계층을 구현할 수 있다.
 * 어떤 방법을 사용하더라도 타입 계층을 구현했다고 해서 그 안에 들어있는 모든 타입 구현체들이 서브타입과 슈퍼타입의 조건을 만족시키는 것은 아니다. 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 구현할 때 리스코프 치환 원칙을 준수해야한다.
 * 여기서 사용된 방법을 사용해 타입 계층을 구현한다고 하더라도 리스코프 치환 원칙을 준수하지 않는다면 올바른 타입 계층을 구현한 것이 아니다(코드 재사용과 서브타이핑을 혼동하고 있는지 고민하자)
 *
 */

@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
