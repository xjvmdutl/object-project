package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 언제 상속을 사용해야 하는가?
 * 상속의 올바른 용도는 타입 계층을 구현하는 것이다.
 * 아래 조건을 모두 만족했을 경우에만 상속을 사용하자
 * - 상속 관계가 is-a 관계를 모델링하는가? = 애플리케이션을 구성하는 어휘에 대한 우리의 관점에 기반하며, 일반적으로 자식 클래스는 부모 클래스다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
 * - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가? = 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야한다. 이를 자식 클래스와 부모 클래스 사이의 행동 호환성이라고 부른다.
 * 설계 관점에서 상속을 적용할지 여부를 결정하기 위해 첫 번째 질문보다는 두번째 질문에 초점을 맞추는 것이 중요하다.
 * 클라이언트의 관점에서 두 클래스에 대해 기대하는 행동이 다르다면 비록 그것이 어휘적으로 is-a 관계로 표현할 수 있다고 하더라도 상속을 사용해서는 안된다.
 *
 * is-a 관계
 * 두 클래스가 어휘적으로 is-a 관계를 모델링할 경우에만 상속을 사용해야 한다.
 * 하지만 is-a 관계가 생각처럼 직관적이고 명쾌한 것은 아니다
 * ex) 펭귄은 새다, 새는 날 수 있다. -> 펭귄은 날 수 있나? 없다. 펭귄은 새지만 날 수 없는 새이다.
 * 이 예는 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여준다.
 * 타입 계층의 의미는 행동이라느 문맥에 따라 달라질 수 있다. 그에 따라 올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다.
 * 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요하다.
 * 이 예는 is-a라는 말을 너무 단편적으로 받아들일 경우에 어떤 혼란이 벌어질 수 있는지를 잘 보여준다.
 * 스콧 마이어스의 말을 인용하자면 "지금 우리는 명확하지 않은 자연어 즉, 사람의 말에 소위 낚인 것이다"
 * 따라서 어떤 두 대상을 언어적으로 is-a라고 표현할 수 있더라도 일단은 상속을 사용할 예비 후보정도로만 생각하라 너무 성급하게 상속을 적용하려고 서두르지 말라
 * 여러분의 애플리케이션 안에서 두 가지 후보 개념이 어떤 방식으로 사용되고 협력하는지 살펴본 후에 상속의 적용 여부를 결정해도 늦지 않다.
 *
 * 행동 호환성
 * 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아햐한다.
 * 새와 펭귄의 서로 다른 행동 방식은 이 둘을 동일한 타입 계층으로 묶어서는 안 된다고 강하게 경고한다.
 * 결론은 두 타입 사이에 행동이 호환될 경우에만 타입계층으로 묶어야 한다는 것이다.
 * 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이다.
 * 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다. 클라이언트가 두 타입이 동일하게 행동하지 않을 것이라고 기대한다면 두 타입을 타입 계층으로 묶어서는 안된다.
 * penguin이 bird의 서브 타입이 아닌 이유는 클라이언트 입자엥서 모든 새가 날 수 있다고 가정했기 때문인데, 단순 is-a라고 표현할 수 있다고 해서 두 타입이 올바른 타입계층을 구성한다고 말할 수 없다.
 * 타입 계층을 이해하기 위해서는 그 타입 계층이 사용될 문맥을 이해하는 것이 중요한 것이다.
 *
 * 클라이언트의 기대에 따라 계층 분리하기
 * 문제를 해결할 수 있는 방법은 크라이언트의 기대에 맞게 상속 계층을 분리하는 것뿐이다.
 * 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족시킬 수 있을 것이다.
 * 인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야 한다는 것을 기억하라.
 * 히나의 클라이언트가 오직 fly 메시지만 전송하기를 원한다면 이 클라이언트에게는 fly 메시지만 보여야 한다.
 * 다른 클라이언트가 오직 walk 메시지만 전송하기를 원한다면 이 클라이언트에게는 walk 메시지만 보여야하낟.
 * 따라서 가장 좋은 방법은 fly 오퍼레이션을 가진 Flyer 인터페이스와 walk 오퍼레이션을 가진 Walker 인터페이스로 분리하는 것이다.
 * 만약 Penguin이 Bird의 코드를 재사용해야 한다면 어떻게 할까 -> 상속은 Penguin의 퍼블릭 인터페이스에 fly 오퍼레이션이 추가되기 때문에 사용할 수 없다.
 * 합성을 사용하는 것이다. 물론 Bird의 퍼블릭 인터페이스를 통해 재사용 가능하다는 전제를 만족시켜야한다.
 * 대부분의 경우에는 불안정한 상속 계층을 계속 껴안고 가는 것보다는 Bird를 재사용 가능하도록 수정하는 것이 더 좋은 방법이다.
 * 클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있게 된다. 대부분의 경우 인터페이스는 클라이언트의 요구가 바뀜에 따라 변경된다.
 * 클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급 효과를 효과적으로 제어할수 있게 된다.
 * 이처럼 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙이라고 부른다.
 * - 비대한 클래스는 그 클라이언트 사이에 이상하고 해로운 결합이 생기게 만든다. 한 클라이언트가 이 비대한 클래스에 변경을 가하면, 나머지 모든 클래스가 영향을 받게 된다.
 * - 그러므로 클라이언트는 자신이 호출하는 메서드에만 의존해야한다. 이것은 비대한 클래스의 인터페이스를 여러 개의 클라이언트에 특화된 인터페이스로 분리함으로써 성취될 수 있다.
 * 설계는 꼭 현실 세계를 반영할 필요는 없다. 중요한 것은 설계가 반영할 도메인의 요구사항이고 그 안에서 클라이언트가 객체에게 요구하는 행동이다.
 * 현재의 요구사항이 날 수 있는 행동에 관심이 없다면 상속 계층에 FlyBird를 추가하는 것은 설계를 불필요하게 복잡하게 만든다.
 * 현실을 정확하게 묘사하는 것이 아니라 요구사항을 실용적으로 수용하는 것을 목표로 삼아야한다.
 * - 최고의 설계는 제작하려는 소프트웨어 시스템이 기대하는 바에 따라 달라진다. 실제로 이런 것들을 잘 구분해서 설계하는 쪽이 바람직하다.
 * - 나는 새도 있고, 날 수 없는 새도 있다는 사실은 여러분이 본뜨려고 하는 세계가 어떤 것이냐에 따라 고려해도 되고 고려하지 않아도 되기 때문이다.
 * 요점은 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중하라는 것이다.
 * 클래스의 이름 사이에 어떤 연관성이 있다는 사실은 아무런 의미도 없다. 두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니기 때문에 상속을 사용해서는 안된디.
 *
 * 서블클래싱과 서브타이핑
 * 상속은 코드 재사용(서브클래싱)을 위해서, 타입 계층을 구성(서브타이핑)하기 위해서 사용해야 한다.
 * 서브클래싱: 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리킨다. 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.(구현 상속, 클래스 상속이라고도 부른다)
 * 서브타이핑: 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다. 서브타이핑에서는 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 크랠스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. 부모 클래스는 자식 클래스의 슈퍼 타입, 자식클래스는 부모 클래스의 서브타입이 된다.(인터페이스 상속이라고도 부른다)
 * 서브클래싱과 서브타이핑을 나누는 기준은 상속을 사용하는 목적이다.
 * 자식 클래스가 부모 클래스의 코드를 재사용할 목적으로 상속을 사용했다면 그것은 서브클래싱이고, 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용할 목적으로 상속을 사용했다면 그것은 서브타이핑이다.
 * - 클래스 상속은 객체의 구현을 정의할 때 이미 정의된 객체의 구현을 바탕으로 한다. 즉 코드 공유의 방법이다. 이에 비해 인터페이스 상속은 객체가 다른 곳에서 사용될 수 있음을 의미한다.
 * - 인터페이스 상속 관계를 갖는 경우 프로그램에는 슈퍼타입으로 정의하지만 런타임에 서브타입의 객체로 대체할 수 있다.
 * 슈퍼타입과 서브타입 사이의 관계에서 가장 중요한 것은 퍼블릭 인터페이스이다.
 * 슈퍼타입 인스턴스를 요구하는 모든 곳에서 서브타입의 인스턴스를 대신 사용하기 위해 만족해야 하는 최소한의 조건은 서브타입의 퍼블릭 인터페이스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션을 포함해야 한다는 것이다.
 * 따라서 개념적으로 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속 받는 것처럼 보이게 된다(서브타이핑이 인터페이스 상속이라 불리는 이유)
 * 서브클래싱은 클래스의 내부 구현 자체를 상속받는 것에 초점을 맞추기 때문에 구현 상속, 클래스 상속이라고 불린다.
 * 서브타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다. -> 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행동 호환성을 만족시켜야 한다.
 * 자식 클래스가 부모 클래스를 대신할 수 있기 위해서는 자식클래스가 부모 클래스가 사용되는 모든 문맥에서 자식 클래스와 동일하게 행동할 수 있어야 한다.
 * 그리고 행동 호환성을 만족하는 상속 관계는 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장해야 한다.
 * -> 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성을 포함한다.
 * 행동 호환성과 대체 가능성은 올바른 상속 관계를 구축하기 위해 따라야 할 지침이라고 할 수 있다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
