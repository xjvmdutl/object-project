package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 클래스는 추상 데이터 타입인가?
 * 추상 데이터 타입과 클래스는 동일하지 않다. -> 클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다.
 * 상속과 다형성을 지원하는 객체지향 프로그래밍과 이를 지원하지 않는 추상 데이터 타입 기반의 객체 기반 프로그래밍 으로 구분한다.
 * 추상 데이터 타입은 타입을 추상화한 것이고 클래스는 절차를 추상화한 것이다.
 * 하나의 대표적인 타입이 다수의 세부적인 타입을 감추는 것을 타입 추상화라고 불렀다. 타입 추상화는 개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄하도록 함으로써 하나의 물리적인 타입안에 전체 타입을 감춘다.
 * 타입 추상화는 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법이다. -> 타입 추상화를 기반으로 하는 대표적인 기법이 추상 데이터 타입이다.
 * 추상 데이터 타입이 오퍼레이션을 기준으로 타입을 묶는 방법이라면 객체지향은 타입을 기준으로 오퍼레이션을 묶는다.
 * 공통 로직을 제공할 수 있는 가장 간단한 방법은 공통 로직을 포함할 부모 클래스를 정의하고 두 직원 유형의 클래스가 부모 클래스를 상속받게 하는것이다.
 * 이제 클라이언트는 부모 클래스의 참조자에 대해 메시지를 전송하면 실제 클래스가 무엇인가에 따라 적절한 절차가 실행되며 동일한 메시지에 대해 서로 다르게 반응한다 -> 다형성
 * 클라이언트의 관점에서 두 클래스의 인스턴스는 동일하게 보이는 것에 주목해라. -> 실제로 내부에서 수행되는 절차는 다르지만 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다(객체지향 == 절차 추상화)
 * 추상 데이터 타입은 오퍼레이션을 기준으로 타입들을 추상화한다.<-> 클래스는 타입을 기준으로 절차를 추상화한다.
 *
 * 변경을 기준으로 선택하라
 * 단순히 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지는 않는다.
 * 클래스가 추상데이터 타입의 개념을 따르는지를 확인할 수 있는 가장 간단한 방법은 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지를 살펴보는 것이다.
 * 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주된다.
 * 객체지향에서는 타입 변수를 이요한 조건문을 다형성으로 대체한다.
 * 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다.
 * 기존 코드에 아무런 영향을 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 개방-폐쇄 원칙이라고 부른다.
 * 설계는 변경과 관련된 것이다. 설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.
 * 추상 데이터 타입과 객체지향 설계의 유용성은 설계에 요구되는 변경의 압력이 타입 추가에 관한 것인지 아님 오퍼레이션 추가에 관한 것인지에 따라 달라진다.
 * 타입 추가라는 변경의 압력이 더 강한 경우에는 객체지향의 손을 들어줘야 한다. -> 추상 데이터 타입의 경우 새로운 타입 추가시, 타입을 체크하는 클라이언트 코드를 수정 후 테스트 해야하지만, 객체지향의 경우 클라이언트 코드 수정이 필요없다.
 * 변경의 주된 압력이 오퍼레이션을 추가하는 것이라면 추상 데이터 타입의 승리를 선언해야 한다. -> 객체지향의 경우 새로운 오퍼레이션을 추가하기 위해서는 상속 계층에 속하는 모든 클래스를 한번에 수정해야하지만, 추상 데이터 타입의 경우 전체 타입에 대한 구현 코드가 하나의 구현체 내에 포함돼 있기 때문에 새로운 오퍼레이션 추가 작업이 간단하다.
 *
 * 협력이 중요하다.
 * 객체지향에서 중요한 것은 역할, 책임, 협력이다. 객체지향은 기능을 수행하기 위해 객체들이 협력하는 방식에 집중한다.
 * 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션의 구현 방식을 타입별로 분배하는 것은 올바른 접근법이 아니다.
 * 객체가 참여할 협력을 결정하고 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민해라.
 * 그 책임을 다양한 방식으로 수행해야할 때만 타입 계층 안에 각 절차를 추상화하라.
 * 타입 계층과 다형성은 협력이라는 문맥안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며, 그 자체가 목적이 되어서는 안된다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
