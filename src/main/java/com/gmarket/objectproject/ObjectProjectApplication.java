package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 객체지향 원칙을 따르는 애플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고 다양한 객체들 사이에 균형 있게 분배되어 있다.
 * -> 객체들은 요청의 흐름을 따라 자신에게 분배된 로직을 실행하면서 애플리케이션의 전체 기능을 완성한다.
 * 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고 한다.
 * 객체가 협력에 참여하기 위해 수행하는 로직은 책임이라고 한다.
 * 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다.
 *
 * 협력
 * 협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법으로 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.
 * 메시지 전송은 객체사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이며, 메시지 전송을 통해서만 자신의 요청을 전달할 수 있다.
 * 메시지를 수신한 객체는 메서드를 실행해 요청에 응답한다 -> 외부의 객체는 오직 메시지만 전송할 수 있을 뿐이며, 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.
 * 자율적인 객체란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체다. -> 객체의 자율성을 보장하기 위해서는 필요한 정보와 정보에 기반한 행동을 같은 객체에 모아두어야 한다.
 * 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다.-> 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.
 * 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해 협력을 요청한다.
 * 메시지를 수신한 객체 역시 메시지를 처리하던 중에 직접 처리할 수 없는 정보나 행동이 필요한 경우 다른 객체에게 도움을 요청한다.
 *
 * 협력이 설계를 위한 문맥을 결정한다
 * 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야한다. -> 그 객체는 어떤 협력에 참여하고 있기 때문이며, 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유했기 때문이다.
 * 객체의 행동을 결정하는 것은 객체가 참여하고 있느 협력이다 -> 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 하며, 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.
 * 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다. -> 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다
 * 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.
 * 상태는 객체가 행동하는 데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정되므로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다.
 * 협력은 객체를 설계하는 데 필요한 일종의 문맥을 제공한다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
