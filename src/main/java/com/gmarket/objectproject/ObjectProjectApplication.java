package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 도메인 모델에 관하여
 * 도메인이란 사용자가 프로그램을 사용하는 대상 영역을 가리킨다. 모델이란 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.
 * 도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다
 * 객체지향 분석 설계에서 제안하는 지침 중 하나는 소프트웨어의 도메인에 대해 고민하고 도메인 모델을 기반으로 소프트웨어를 구축하라는 것이다. -> 개념과 소프트웨어 사이의 표현적 차이를 줄일 수 있기 때문에 이해하고 수정하기 쉬운 소프트웨어를 만들 수 있다.
 * 도메인 모델을 작성하는 것이 목표가 아니라 출발점이라는 것이다. 도메인 모델은 소프트웨어를 만드는 데 필요한 개념의 이름과 의미 그리고 관계에 대한 힌트를 제공하는 역할로 끝나야 한다.
 * - 모델은 옳거나 틀린 것이 아니다. 모델은 유용하거나 유용하지 않은 정도의 차이만 있을 뿐이다.
 * 불행은 도메인 안의 개념이 제공하는 틀에 맞춰서 소프트웨어를 구축해야 한다고 생각할 때부터 시작된다. 도메인 모델이 클래스 다이어그램과 같은 정적 모델에 기반해야 한다는 오해 역시 잘목된 코드 구조를 낳는 원인이 된다.
 * 도메인 모델은 여러분의 도메인에 대한 지식을 표현하고 코드의 구조에 대한 힌트를 제공할 수 있다면 어떤 형태로 표현하더라도 상관이 없다.
 * 우리에게 중요한 것은 소프트웨어의 기능과 객체의 책임이다. -> 도메인 안의 개념들을 기반으로 출발하되 객체들의 협력이 도메인 모델에 맞지 않는다면 필요한 몇가지 개념만 남기고 도메인 모델을 과감하게 수정하자
 * 중요한 것은 객체들의 협력을 지원하는 코드 구조를 만드는 것이다. 도메인의 개념을 충실히 따르는 코드가 목적이 아니다. 코드의 구조를 주도하는 것은 구조가 아니라 행동이라는 사실을 기억하자
 * 도메인 모델에 지나치게 집착하거나 도메인 모델의 초기 구조를 맹목적으로 따르는 코드를 작성하고 있다면 변경하기 어려운 소프트웨어가 만들어질 확률이 높다.
 *
 * 행동과 변경을 고려한 도메인 모델
 * 우리는 도메인 모델을 먼저 만들고 만들어진 도메인 모델에 표현된 개념과 관계를 기반으로 협력에 필요한 객체의 후보를 도출하고 구현 클래스의 이름과 관계를 설계한다. 하지만 도메인 모델을 그대로 카피해서는 안된다.
 * 더 많은 지식이 쌓이고 요구사항이 분명해지면, 초기의 아이디어에 대한 미련을 버리고 현명한 판단을 내려야한다.
 * 구현하거나 변경하기 더 쉬운 모델이 떠올랐다면 과감하게 초기 아이디어를 버려라. 객체지향의 핵심은 객체 사이의 협력이며 설계는 변경을 위한 것이다. 따라서 행동과 변경을 고려하지 않은 채 도메인 모델을 그대로 따르는 설계는 유지보수를 방해할 뿐이다.
 * 게임의 도메인에는 용과 트롤이 들어가지만, 변경한 설계에는 그런 지식이 녹아 있지 않다. 몬스터의 종류를 JSON 형식으로 서술한다면 도메인 전체에 대해 이해하기가 쉬워진다.
 * 도메인 모델은 단순히 클래스 다이어그램이 아니다. 도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이 도메인 모델이다.
 * 그리고 그렇게 작성된 개념이 여러분의 코드에 대한 구조와 행동을 드러낸다면 그것은 더없이 훌룡한 모델이다. 형식은 중요하지 않다. 중요한 것은 전달하려는 의미다.
 * 간단한 JSON 역직렬화기를 구현하면 우리가 정리한 JSON 데이터를 실제 애플리케이션에서 사용할 수 있다.-> 새로운 몬스터를 추가하기 위해 코드를 작성할 필요없이 JSON에 새로운 종류를 표현하는 데이터 한줄 더 추가하기만 하면 된다.
 * 이 예는 도메인 모델과 우리의 코드가 별개의 것이 아닐 수 있으며, 그 간격이 좁을수록 좋다는 사실을 잘 보여준다.
 * 도메인 모델이 단순히 정적 모델의 형태를 띨 필요가 없으며 도메인 모델의 구조가 코드와 다를 필요가 없다. 도메인 모델은 코드를 위한 것이다.
 * 도메인 모델은 도메인 안에 존재하는 개념과 관계를 표현해야 하지만 최종 모습은 객체의 행동과 변경에 기반해야 하며 코드의 구조를 반영해야 한다.
 * 중요한 것은 도메인 모델을 봤을 때 도메인의 개념뿐만 아니라 코드도 함께 이해될 수 있는 구조를 찾는 것이다.
 *
 * 분석 모델, 설계 모델, 그리고 구현 모델
 * 분석 모델: 해결 방법에 대한 언급 없이 문제 도메인을 설명하는 모델, 분석 모델은 순수하게 문제 도메인에 초점을 맞춰야 하며 기술적인 해결 방법을 언급해서는 안 된다.
 * 설계 모델: 분석 모델을 바탕으로 기술적인 관점에서 솔루션을 서술하는 모델
 * 구현 모델: 설계 모델을 바탕으로 프로그래밍 언어를 사용해 컴퓨터가 이해할 수 있는 명령어로 변환하는 모델
 * 분석, 설계, 구현 모델을 명확하게 구분하는 것은 가능하지 않을 뿐더러 오히려 소프트웨어의 품질에 악영향을 미친다. 우리가 원하는 것은 분석과 설게와 구현 동안 동일한 모델을 유지하는 것이다.
 * 도메인 모델이 코드와 동일한 형태를 가진다는 것은 분석, 설계, 구현에 걸쳐 동일한 모델을 사용한다는 것을 의미한다. 객체지향 패러다임이 과거의 다른 패러다임과 구별되는 가장 큰 차이점은 소프트웨어를 개발하기 위한 전체 주기 동안 동일한 설계 기법과 모델링 방법을 상요 할 수 있다는 것이다.
 * 프로그래밍 작업 동안 설계의 실현 가능성과 정확성이 검증되고 테스트되고, 그 결과로 잘못된 설계가 수정되거나 새로운 설계로 대체된다. 따라서 프로그래밍은 설계의 한 과정이며 설계는 프로그래밍을 통해 개선된다.
 * 따라서 분석과 설계와 구현 간의 구분이 방법론과 프로젝트 관리를 위해 필요한 중요 요소라고 하더라도 모델과 코드 간의 관계에 이를 강요해서는 안 된다.
 * 프로젝트 내에서 분석 모델을 설계 모델로 변환하는 작업에 많은 시간을 소비하고 있다면 설계 모델을 도메인을 반영하도록 수정하고 분석 모델을 폐기처분하자.
 * 코드와 모델의 차이를 줄이기 위해서는 도메인과 코드 간의 차이가 적어야한다. 햔제 프로그램의 패러다임을 주도하고 있는 객체지향의 가장 큰 힘은 도메인을 표현하는 방법과 프로그램 코드를 표현하는 방법이 동일하다는 것이다.
 * 분석 모델과 설계 모델과 구현 모델이 다르다는 생각을 버려라.그리고 분석과 설계와 구현이 별개의 활동이라는 생각 역시 버려라.
 * - 설계 혹은 설계의 주도니 부분이 도메인 모델과 대응하지 않는다면 그 모델은 그다지 가치가 없으며, 소프트웨어의 정확성도 의심스러워진다.
 * 정리하자면 여러분의 코드는 도메인의 갬념적인 분류 체계가 아니라 객체의 행동과 변경에 영향을 받는다. 그리고 객체지향 패러다임에 대한 흔한 오해와는 다르게 분석 모델과 설계 모델, 구현 모델 사이에 어떤 차이점도 존재하지 않는다.
 * 이것들은 모두 행동과 변경이라는 요소에 영향을 받으며 전체 개발 주기 동안 동일한 모양을 지녀야 한다.
 * 객체지향 패러다임이 강력한 이유는 전체 개발 주기에 걸쳐 동일한 기법과 표현력을 유지할 수 있다는 점이다. 분석, 설계, 구현 단계 사이에 세부적인 내용은 다를 수 있겠지만 설계의 초점은 동일하다.
 * 결국 모든 단계에 걸쳐 행동과 변경에 초점을 맞춰야한다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
