package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 상속으로 인해 결합도가 높아지면 코드를 수정하는데 필요한 작업의 양이 과도하게 늘어난다. -> 일반적으로 작은 기능들을 조합해 더 큰 기능을 수행하는 객체를 만들어야 할때
 * 문제점
 * - 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
 * - 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.
 *
 * 기본 정책과 부가 정책 조합하기
 * 요금제 계산 프로그램에 요구사항 추가(부가 정책 추가)
 * - 기본 정책의 계산 결과에 적용
 * - 선택적으로 적용할 수 있다.
 * - 조합 가능하다
 * - 부가 정책은 임의의 순서로 적용 가능하다.
 * ----> 나올수있는 경우의 수 10가지
 *
 * 중복 코드의 덫에 걸리다.
 * 상속은 새로운 정책을 추가하기가 힘들다 -> 기본 정책 추가 시 5개의 새로운 클래스를 추가해야하며, 새로운 부가 정책 추가시, 몇개의 클래스를 추가할지 가늠이 안된다(매우 많이 추가해야한다)
 * 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 클래스 폭발 문제, 조합의 폭발 문제라고 한다.
 * 클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계 때문에 발생하는 문제다.
 * 컴파일타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문에 자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결 방법은 조합의 수만큼 새로운 클래스를 추가하는 것 뿐이다.
 * 클래스 폭발 문제는 기능을 수정할 때도 문제가 되는데 만약 세금 정책을 변경해야 한다면 세금 정책과 관련된 코드가 여러 클래스 안에 중복돼 있기 때문에 세금 정책과 관련된 모든 클래스를 찾아 동일한 방식으로 수정해야 할 것이다.
 * -> 이 클래스 중에서 하나라도 누락한다면 세금이 부과되지 않는 버그가 발생할 것이다.
 * 이 문제를 해결할 수 있는 최선의 방법은 상속을 포기하는 것이다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
