package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 상속의 첫 번째 용도는 타입 계층을 구현하는 것이다. -> 타입 계층의 관점에서 부모 클래스는 자식 클래스의 일반화이고, 자식 클래스는 부모 클래스의 특수화다.
 * 상속의 두 번째 용도는 코드 재사용이다. -> 상속을 사용하면 점진적으로 애플리케이션의 기능을 확장할 수 있다. 단, 재상용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높다.
 * 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다. -> 상속은 코드를 쉽게 재사용할 수 있는 방법을 제공하지만 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 설계의 변경과 진화를 방해한다.
 * 타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있게 된다.
 * 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야한다.
 * 객체지향 프로그래밍과 객체기반 프로그래밍
 * -> 객체 기반 프로그래밍이란 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식을 가리키고, 객체지향 프로그래밍 역시 객체기반 프로그래밍의 한 종류로, 상속과 다형성을 지원하는 점에서 차별화된다.
 *
 * 개념 관점의 타입
 * 개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다. -> 타입은 사물을 분류하기 위한 툴로 사용된다.
 * 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 부른다. 일반적으로 타입의 인스턴스를 객체라고 부른다.
 * 타입은 심볼, 내연, 외연 3가지 요소로 구성된다.
 * 심볼: 타입에 이름을 붙인 것이다(프로그래밍 언어)
 * 내연: 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다(프로그래밍 언어의 정의) -> 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성
 * 외연: 타입에 속하는 객체들의 집합이다.(프로그래밍 언어 종류 => 자바, 루비, 파이썬..)
 *
 * 프로그래밍 언어 관점의 타입
 * 프로그래밍 언어 관점에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다. -> 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다.
 * 프로그래밍 언어에서 타입의 목적
 * - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다. -> 모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다.
 * - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.
 * -> a,b가 int면 더하고, a,b가 string이면 문자열을 더할 것이다(a,b 부여된 타입이 +연산자의 문맥을 정의)
 * -> new 연산자는 타입에 정의된 크기만큼 저장 공간을 할당하고 생성된 객체를 초기화하기 위해 타입의 생성자를 자동호출한다.(객체의 타입이 객체를 생성하는 방법에 대한 문맥을 결정)
 * 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.
 *
 * 객체지향 패러다임 관점의 타입
 * - 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다.
 * - 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.
 * 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다. 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다.
 * 객체지향에서는 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류하기 땜누에 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입으로 분류할 수 있다.
 * 결론: 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
 * 객체에게 중요한 것은 속성이 아닌 행동이다.
 * 어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르면 이들은 서로 다른 타입으로 분류되지만 반대로 어떤 객체들이 내부 상태는 다르지만 동일한 퍼블릭 인터페이스를 공유한다면 이들은 동일한 타입으로 분류된다.
 * 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
