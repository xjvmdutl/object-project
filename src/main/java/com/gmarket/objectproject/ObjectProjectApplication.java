package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 의존성과 결합도
 * 객체지향 패러다임의 근간은 협력이다. 하지만 의존성이 과하면 문제가 될 수 있다.
 * 의존성의 존재보단 정도가 문제가 된다.
 * 구체적인 클래스에 의존하게 만들어 버리면 다른 종류의 할인 정책이 필요한 문맥에서 재사용할 수 있는 가능성을 없애 버린다.
 * 해결 방법은 의존성을 바람직하게 만드는 것이다. -> Movie 입장에서는 협력할 클래스를 고정할 필요 없이 자신이 전송하는 메시지만 이해할 수 있고 할인된 요금만 계산할 수 있다면 어떤 타입의 객체와 협력하더라도 상관이 없다.
 * Movie 클래스가 오직 DiscountPolicy에만 의존하도록 만듦으로써 DiscountPolicy 클래스에 대한 컴파일타임 의존성을 AmountDiscountPolicy, PercentDiscountPolicy 인스턴스에 대한 런타임 의존성으로 변경이 가능하다.
 * 바람직한 의존성은 재사용성과 관련이 있으며 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다.
 * 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.
 * 컨텍스트 독립적인 의존성은 바람직한 의존성이고, 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.
 * 특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변겨하는 것뿐이다.
 * 바람직한 의존성이란 컨텍스트에 독립적인 의존성을 의미하며 다양한 환경에서 재사용될 수 있는 가능성을 열어놓는 의존성을 의미한다.
 * 어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 느슨한 결합도/약한 결합도를 가진다고 말한다. 반대로 두 요소 사이의 의존성이 바람직하지 못할 때 단단한 결합도/강한 결합도를 가진다고 한다.
 * 바람직한 의존성이란 설계를 재사용하기 쉽게 만드는 의존성이며, 바람직하지 못한 의존성이란 설계를 재사용하기 어렵게 만드는 의존성이다.
 * 어떤 의존성이 재사용을 방해한다면 결합도가 강하다고 표현하며, 어떤 의존성이 재사용을 쉽게 허용한다면 결합도가 느슨하다고 표현한다.
 *
 * 지식이 결합을 낳는다.
 * 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고있는 정보의 양으로 결정되며, 한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 강하게 결합되고 더 적은 정보를 알고 있을수록 약하게 결합된다.
 * Movie가 PercentDiscountPolicy에 직접 의존한다면, 협력할 객체가 비율 할인 정책에 따라 할인 요금을 계산할 것이라느 사실을 알고 있다.
 * Movie가 DiscountPolicy에 의존한다면, 구체적인 계산 방법은 알 필요 없이 할인 요금을 계산한다는 사실만 알고 있다. -> 그 결과 알아야 하는 지식의 양이 적기 때문에 결합도가 느슨해진다.
 * 더 많이 알수록 더 많이 결합된다. 더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미하며 기존 지식에 어울리지 않는 컨텍스트에서 클래스의 인스턴스를 사용하기 위해서 할 수 있는 유일한 방법은 클래스를 수정하는 것뿐이다.
 * 결합도를 느슨하게 유지하려면 협력하는 대상에 대해 더 적게 알아야하며, 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는것이 좋다.
 * 이 목적을 달성할 수 있는 가장 효과적인 방법이 추상화이다.
 *
 * 추상화에 의존하라
 * 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
 * 추상화를 사용하면 현재 다루는 문제를 해결하는데 불필요한 정보를 감출 수 있으며, 대상에 대해 알아야하는 지식의 양을 줄일 수 있기 때문에 결합도도 느슨하게 유지 가능하다.
 * 결합도가 느슨해지는 순위
 * 1) 구체 클래스 의존성
 * 2) 추상 클래스 의존성
 * 3) 인터페이스 의존성
 * 구체 클래스에 비해 추상 클래스는 메서드 내부 구현과 자식 클래스의 종류에 대한 지식을 클라이언트에게 숨길 수 있다 -> 결합도가 낮다, 하지만 여전히 협력하는 대상이 속한 클래스 상속 계층이 무엇인지에 대해 알아야한다.
 * 인터페이스 의존하면 상속 계층을 모르더라도 협력이 가능해지며 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문에 추상 클래스 의종성보다 결합도가 낮아진다.
 * -> 이것은 다양한 클래스 상속 계층에 속한 객체들이 동일한 메시지를 수신할 수 있도록 컨텍스트를 확장하는 것을 가능하게 한다.
 * 실행 컨텍스트에 대해 알아야하는 정보를 줄일수록 결합도가 낮아진다. -> 의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다.
 *
 * 명시적인 의존성
 * 결합도를 느슨하게 만들기 위해서는 인스턴스 변수의 타입을 추상 클래스나 인터페이스로 선언하는 것만으로는 부족하다.
 * 클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야만 한다.
 * 의존성을 해결하는 방법은 생성자, setter 메서드, 메서드 인자를 사용하는 3가지 방법이다.
 * 여기서의 트릭은 인스턴스 변수의 타입은 추상 클래스나, 인터페이스로 정의 하고 생성자, setter 메서드, 메서드 인자로 의존성을 해결할 떄는 추상 클래스를 상속받거나 인터페이스를 실체화한 구체 클래스를 전달하는 것이다.
 * 생성자로 해결하기 위해서는 생성자 안에서 인스턴스를 직접 생성하지 않고 생성자의 인자로 선언해야한다. -> 생성자의 인자가 추상 클래스 타입으로 선언됐기 떄문에 객체를 생성할 때 생성자의 인자로 DiscountPolicy 자식 클래스중 어떤 것이라도 전달할 수 있다.
 * 따라서 런타임에 인스턴스를 선택적으로 전달할 수있고, Movie 인스턴스는 생성자의 인자로 전달된 인스턴스에 의존하게 된다.
 * 의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지 여부다.
 * 의존성을 명시적으로 퍼블릭 인터페이스에 노출시키는 경우를 명시적인 의존성이라고 부른다.
 * 의존성이 퍼블릭 인터페이스에 표현되지 않는 방식을 숨겨진 의존성이라고 부른다.
 * 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없고, 커다란 클래스에 저으이된 긴 메서드 내부 어딘가에서 인스턴스를 생성하는 코드를 파악하는 것은 쉽지않고 고통스럽다.
 * 더 큰 문제는 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다는 것이다. -> 코드 수정은 항상 잠재적 버그 발을 야기하며, 의존성을 명시적으로 드러내면 코드를 직접 수정하는 위험을 피할 수 있다(실행 컨텍스트에 적절한 의존성을 선택할 수 있기때문)
 * 의존성은 명시적으로 표현돼야한다. 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다. 명시적인 의존성을 사용해야 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.
 * 경계해야하는 것은 의존성 자체가 아닌 의존성을 감추는 것으로 숨겨져 있는 의존성을 밝은 곳으로 드러내서 널리 알려라
 *
 * new는 해롭다
 * 대부분의 언어에서는 클래스의 인스턴스를 생성할 수 있는 new 연산자를 제공하지만, new 를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다.
 * - new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. -> new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 떄문에 결합도가 높아진다.
 * - new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. -> new를 사용하면 클라이언트가 알아야하는 지식의 양이 늘언나기 떄문에 결합도가 높아진다.
 * 구체 클래스에 직접 의존하면 결합도가 높아진다. -> new는 클라이언트가 구체 클래스를 생성하는데 어떤 정보가 필요한지에 대해서도 알아야 하기 때문에 결합도가 높아진다.
 * 결합도가 높으면 변경에 의해 영향을 받기 쉬워진다.
 * Movie가 DiscountPolicy에 의존해야 하는 유일한 이유는 calculateDiscountAmount 메시지를 전송하기 위해서다.
 * 메시지에 대한 의존성 외의 모든 다른 의존성은 movie의 결합도를 높이는 불필요한 의존성이다. ->new는 이런 불필요한 결합도를 급격하게 높인다.
 * new는 협력할 클래스의 인스턴스를 생성하기 위해 어떤 인자들이 필요하고 그 인자들을 어떤 순서로 사용해야 하는지에 대한 정보도 노출시킬 뿐만 아니라 인자로 사용되는 구체 클래스에 대한 의존성을 추가한다.
 * 해결 방법으로는 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것이다.
 * 해당하는 인스턴스를 생성하면 안된다 -> 사용하기만 해야한다.
 * 사용과 생성의 책임을 분리해서 Movie의 결합도를 낮추면 설계를 유연하게 만들 수 있다. -> 생성의 책임을 클라이언트로 옮김으로써 Movie는 DiscountPolicy의 모든 자식 클래스와 협력할 수 있게 됐다.
 * 사용과 생성의 책임을 분리하고 의존성을 생성자에 명시적으로 드러내고 구체 클래스가 아닌 추상 클래스에 의존하게 함으로써 설계를 유연하게 만들 수 있다.
 * 그리고 그 출발은 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작했다.!!!
 *
 * 가끔은 생성해도 무방하다.
 * 클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다. 주로 협력하는 기본 객체를 설정하고 싶은 경우가 여기에 속한다.
 * movie의 대부분의 경우가 AmountDiscountPolicy와 협력할 경우 모든 인스턴스를 생성하는 책임을 클라이언트로 옮긴다면 클라이언트들 사이에 중복 코드가 늘어나고 Movie의 사용성도 나빠질 것이다.
 * 이 문제를 해결하는 방법은 기본 객체를 생성하는 생성자를 추가하고 이 생성자에서 DiscountPolicy의 인스턴스를 인자로 받는 생성자를 체이닝하는 것이다.
 * 이 방법은 메서드를 오버로딩하는 경우에도 사용할 수 있다.
 * -> 설계가 트레이드오프 산물이라는 사실을 증빙하며, 대상은 결합도와 사용성이다.
 * 단, 가급적이면 구체 클래스에 대한 의존성을 제거할 수 있는 방법을 찾아봐라. 종종 모든 결합도가 모이는 새로운 클래스를 추가함으로써 사용성과 유연성이라는 두 마리 토끼를 잡을 수 있는 경우도 있다.
 *
 * 표준 클래스에 대한 의존은 해롭지 않다.
 * 의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 떄문이다.
 * 따라서 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다(JDK에 포함된 표준 클래스)
 * 이런 클래스에 대해서는 구체 클래스에 의존하거나 직접 인스터스를 생성하더라도 문제가 없다.
 * ArrayList에 직접 생성해서 대입하는 코드는 문제가 없다( ArrayList 코드가 수정될 확률은 0에 가깝기 때문에 인스턴스를 직접 생성하더라도 문제가 없다)
 * 클래스를 직접 생성하더라도 가능한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하다. -> 의존성에 의한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계 습관이다.
 *
 * 조합 가능한 행동
 * 다양한 종류의 할인 정책이 필요한 컨텍스트에서 movie를 재사용할 수 있었던 이유는 코드를 직접 수정하지 않고도 협력 대상인 DiscountPolicy 인스턴스를 교체할 수 있었기 때문이다.
 * 어떤 DiscountPolicy의 인스턴스를 Movie에 연결하느냐에 따라 Movie의 행동이 달라진다.
 * 어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다.
 * 유연하고 재사용 가능한 설계는 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수  있다.
 * 유연하고 재상요 가능한 설계는 객체가 어떻게 하는지를 장황하게 나열하지 않고도 객체들의 조합을 통해 무엇을 하는지를 표현하는 클래스들로 구성된다.
 * -> 따라서 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지를 쉽게 파악할 수 있으며 코드에 드러난 로직을 해석할 필요없이 객체가 어떤 객체와 연결되었는지를 보는 것만으로 객체의 행동을 쉽게 예상하고 이해할 수 있다.
 * 선언적으로 객체의 행동을 정의할 수 있는 것이다.
 * 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다.
 * 훌룡한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아닌 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다. 그리고 이런 설계를 찬조하는데 있어서의 핵심은 의존성을 관리하는 것이다.
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
