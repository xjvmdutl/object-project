package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.
 * 루틴: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
 * 프로시저: 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류(부수효과를 발생시킬 수 있지만, 값을 반환할 수 없다)
 * 함수: 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류(값을 반환할 수 있지만, 부수효과를 발생시킬 수 없다)
 * 객체의 상태를 수정하는 오퍼레이션을 명령이라고 부르고, 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.
 * 명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명력이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.
 * - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
 * - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
 * 명령-쿼리 분리 원칙을 설명할 때 기계 메타포를 이용하며, 객체는 블랙박스이며, 객체의 인터페이스는 객체의 관찰가능한 상태를 보기 위한 일련의 디스플레이와, 객체의 상태를 변경하기 위해 누를수 있는 버튼의 집합이다.
 * 이러한 인터페이스를 사용함으로써 객체의 캡슐화와 다양한 문맥에서의 재사용을 보장할 수 있으며, 해당 원칙에 따라 작성된 객체의 인터페이스를 명령-쿼리 인터페이스라고 부른다.
 * 기계 메타포에서 인터페이스는 둥근 모양의 버튼과 네모 모양을 버튼으로 나뉘며, 둥근 모양의 버튼은 기계의 현재 상태를 출력(상태 변경 x), 네모 모양의 버튼은 기계의 상태를 변경(상태 출력 x)한다.
 * 명령 버튼을 누르면 기계의 상태가 변경되지만 직후 기계 내부의 상태를 직접 확인할 수 없으며, 쿼리 버튼은 상태를 변경하지 않지만 디스플레이를 통해 기계의 상태를 메시지 형태로 표시한다.
 *
 * 명령-쿼리 분리와 참조 투명성
 * 명령과 쿼리를 분류하면, 객체의 부수효과를 제어하기가 수월해진다.
 * 쿼리는 객체의 상태를 변경하지 않기 떄문에 몇 번이고 반복 호출되더라도 명령이 개입하지 않는한 쿼리의 값은 변경되지 않는다. 쿼리들의 순서를 자유롭게 변경할 수도 있다.
 * 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적이나마 누릴 수 있게 된다.
 * => 참조 투명성 특성을 잘 이용하면 버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행결과가 변하지 않는 코드를 작성할 수 있다.
 * 컴퓨터 세계와 수학의 세계를 나누는 가장 큰 특징은 부수효과의 존재 유무다. 프로그램에서 부수효과를 발생시키는 두가지 대표적인 문법은 대입문과 함수다.
 * 수학에서는 값을 초기화한 후에는 값을 변경하는 것이 불가능하지만 프로그램에서는 대입문을 이용해 다른 값으로 변경하는 것이 가능하다.
 * -> 함수는 내부에 부수효과를 포함할 경우 동일한 인자를 전달하더라도 부수효과에 의해 그 결괏값이 매번 달라질 수 있다.
 * 참조 투명성이란 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성을 의미한다.
 * 참조 투명성은 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산할 수 있게 해준다.
 * 어떤 값이 변하지 않는 성질을 불변성이라고 하며, 이는 부수효과가 발생하지 않는다는 말과 동일하다.
 * 불변성은 부수효과의 발생을 방지하고 참조 투명성을 만족시킨다.
 * 참조 투명성은 순서를 변경하더라도 결과가 달라지지 않는다.
 * 참조 투명성 장점
 * - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
 * - 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
 * 객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다.
 * 하지만 명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누리게 한다.
 * 부수효과를 기반으로 하는 프로그래밍 방식을 명령형 프로그래밍이라고 하고,부수효과가 존재하지 않는 수학적인 함수에 기반하는 프로그램을 함수형 프로그래밍이라고 한다.
 *
 * 책임에 초점을 맞춰라
 * 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하라. -> 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것이다
 * - 디미터 법칙: 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다.
 * - 묻지 말고 시켜라: 클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.
 * - 의도를 드러내는 인터페이스: 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다. 그 이름에는 당연히 클라이언트가 무엇을 원하는지 의도가 명확하게 들어날 수 밖에 없다
 * - 명령-쿼리 분리 원칙: 메시지를 먼저 선택한다는 것은 협력이라는 문맥안에서 객체의 인터페이스에 관해 고민한다는 것을 의미하며, 객체가 단순히 어떤 일을 해야 하는지 뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다.
 * 책임 주도 설계에서는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하기 때문에 협력에 적합한 메시지를 결정할 수 있는 확률이 높아진다.
 * 지금까지 살펴본 원칙들은 구현과 부수효과를 캡슐화하고 높은 응집도, 낮은 결합도를 가진 인터페이스를 만들 수 있는 지침을 제공하지만, 실제 실행시점에 필요한 구체적인 제약이나 조건을 명확하게 표현하지는 못한다.
 * 협력을 위해 두 객체가 보장해야하는 실행 시점의 제약을 인터페이스에 명시할 수 있는 방법이 존재하지 않는다.
 * 이 문제를 해결하기 위해서는 계약에 의한 설계 개념을 알아야하며, 계약에 의한 설계는 협력을 위해 클라이언트와 서버가 준수해야 하는 제약을 코드 상에 명시적으로 표현하고 강제할 수 있는 방법이다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
