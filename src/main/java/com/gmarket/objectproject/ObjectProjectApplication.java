package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴이라고 부른다.
 * 디자인 패턴의 목적은 설계를 재사용하는 것이다. 디자인 패턴은 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음이다.
 * 프레임워크는 설계와 코드를 함께 재사용하기 위한 것이다. 프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.
 * 프레임워크가 제공하는 아키텍처가 요구사항에 적합하다면 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽고 빠르게 재사용할 수 있다.
 * 디자인 패턴과 프레임워크 모두 일관성 있는 협력과 관련이 있다.
 * 디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공한다. 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.
 * 지자인 패턴이 협력을 일관성 있게 만들기 위해 재사용할 수 있는 설계의 묶음이라면 프레임워크는 일관성 있는 협력을 제공하는 확장 가능한 코드라고 할 수 있다.
 *
 * 소프트웨어 패턴
 * 패턴 특징
 * - 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
 * - 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통 할 수 있다.
 * - 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
 * - 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.
 * 패턴 정의는 하나의 실무 컨텍스트에서 유용하게 사용해 왔고 다른 실무 컨텍스트에서도 유용할 거싱라고 예상되는 아이디어다.
 * 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 아이디어다. 최소 3가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고,유용한 경우에만 패턴으로 간주할 수 있다.
 * 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다. 패턴은 경험의 산물이다.
 * 따라서 실무 경험이 적은 초보자라고 하더라도 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.
 * 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패터넹서 가장 중요한 요소는 패턴의 이름이다. -> 패턴의 이름은 높은 수준의 대화를 가능하게 하는 원천이다.
 * 패턴의 범위가 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현에 의해 서술될 수 있으며, 패턴들을 포함하는 더 큰 패턴 내에 통합될 수 있다.
 * 연관된 패턴들의 집합들이 모여 하나의 패턴 언어를 구성한다고 정의하고 있다. 패턴 언어는 연관된 패턴 카테고리뿐만 아니라 패턴의 생성 규칙과 함께 패턴 언어에 속한 다른 패턴과의 관계 및 협력 규칙을 포함한다.
 * 패턴언어라는 용어가 지닌 제약조건을 완화하기 위해 패턴 시스템이라는 특수한 용어의 사용을 제안하기도 했으나 현재 두 용어는 거의 동일한 의미로 사용하고 있다.
 *
 * 패턴 분류
 * 패턴의 범위나 적용 단계에 따라 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄 4가지로 분류된다.
 * 디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다. 디자인 패턴은 중간 규모의 패턴으로 특정한 설계 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 패러다임에 독립적이다.
 * 아키텍처 패턴은 디자인 패턴 상위에 있으며, 소프트웨어의 전체적인 구조를 결정하기 위해 사용한다. 아키텍처 패턴은 미리 정의된 서브시스템들을 제공하고 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
 * 아키텍처 패턴은 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
 * 디자인 패턴 하위에는 이디엄이 위치한다. 이디엄은 특정 프로그래밍 언어에만 구한된 하위 레벨 패턴으로 주어진 언어의 기능을 사용해 컴포넌트 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다. 이디엄은 언어에 종속적이기 떄문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.
 * 분석 패턴은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다. 분석 패턴은 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다. 분석 패턴은 단 하나의 도메인에 대해서만 적절할 수도 잇고 여러 도메인에 걸쳐 적용할 수도 있다.
 *
 * 패턴과 책임-주도 설게
 * 객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력관계를 구축하는 일이다. 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 요소들의 트레이드오프를 통해 결정된다.
 * 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌룡한 예제를 제공한다.
 * 패턴들의 세부적인 내용이 중요한 것이 아니다. 중요한 것은 패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실이다. 특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구성할 수 있다.
 * 패턴의 구성 요소는 클래스가 아니라 역할이다. 패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시한다. -> 하나의 객체가 3가지 역할 모두를 수행하더라도 문제 없다.
 * 반대로 다수의 클래스가 동일한 역할을 구현할 수도 있다.
 * 디자인 패턴의 구성요소가 클래스와 메서드가 아니라 역할과 책임이라는 사실을 이해하는 것이 중요하다. 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아니라는 점을 이해하는 것 역시 중요하다.
 * 디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다. 패턴을 적용하기 위해서는 패턴에서 제시하는 구조를 그대로 표현하는 것이 아니라 패턴의 기본 구조로부터 출발해서 현재의 요구에 맞게 구조를 수정해야한다는 것을 의미한다.
 *
 * 캡슐화와 디자인 패턴
 * 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.
 * Strategy 패턴의 목적은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.
 * TemplateMethod 패턴은 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화 할 수 있는 디자인 패턴이다. -> 알고리즘을 캡슐화 하기 위해 합성 관계가 아닌 상속 관계를 사용한다.
 * 다만 합성 보다는 결합도가 높은 상속을 사용했기 때문에Strategy 패턴처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능하지만, 알고리즘 교체와 같은 요구사항이 없다면 상대적으로 strategy 패턴보다 복잡도를 낮출 수 있다는 면에서 장점이다.
 * Decorator 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로써 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다. -> 선택적인 행동의 갯수와 순서에 대한 변경을 캡슐화 할 수 있다.
 * Composite 패턴은 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화하는 것이 목적이다.
 * 대부분의 디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다. 디자인 패턴에서 중요한 것은 디자인 패턴 구현 방법이나 구조가 아니다
 * -> 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다. 그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요하다.
 *
 * 패턴은 출발점이다.
 * 패턴은 설계의 목표가 되어서는 안된다. 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과하다.
 * 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라
 * 패턴을 사용하면서 부딪히게 되는 대부분의 문제는 패턴을 맹목적으로 사용할 때 발생하낟. 대부분의 패턴 입문자가 빠지기 쉬운 함정은 패턴을 적용하는 컨텍스트의 적절성은 무시한 채 패턴의 구조에만 초점을 맞추는 것이다.
 * 패턴 만능주의: 패턴을 익힌 후에는 모든 설계 문제를 패턴으로 해결하려고 시도한다.
 * 부적절한 상황에서 부적절하게 사용된 패턴으로 인해 소프트웨어의 엔트로피가 증가하는 부작용을 낳기 쉽다. 패턴을 남용하지 않기 위해서는 다양한 트레이드오프 관계 속에서 패턴을 적용하고 사용해 본 경험이 필요하다.
 * 전문가는 다양한 실무 경험을 통해 어떤 컨텍스트에서 어떤 패턴을 적용해야 하는지 더 중요한 것으로 어떤 패턴을 적용해서는 안되는지에 대한 감각을 익히고 있다.
 * 명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해진다. 타당한 이슈 없이 패턴을 적용하면 패턴에 익순한 사람들의 경우 설계의 의도를 이해하지 못하게 되고, 패턴을 알지 못하는 사람들은 불필요하게 복잡한 설계를 따라가느라 시간 낭비하게 된다.
 * 정단한 이유 없이 사용된 모든 패턴을 설계를 복잡하게 만드는 장애물이다. 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화돼야 한다. 패턴을 적용할 때는 항상 설계를 좀 더 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민해야 한다.
 * 또한 코드를 공유하는 모든 사람들이 적용된 패턴을 알고 있어야한다. 그렇지 않다면 설계에 대한 지식과 더불어 패턴에 대한 지식도 함께 공유하는 것이 필요하다.
 * 패턴을 가장 효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리펙터링하는 것이다.
 * 패턴은 공통적인 문제에 적절한 해법을 제공하지만 공통적인 해법이 우리가 직면한 문제에 적합하지 않을 수 있다. 문제를 분석하고 창의력을 발휘함으로써 패턴을 현재의 문제에 적합하도록 적절하게 수정하라.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
