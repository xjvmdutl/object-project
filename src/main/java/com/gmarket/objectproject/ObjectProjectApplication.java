package com.gmarket.objectproject;

import java.util.Stack;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 취약한 기반 클래스 문제라고 부른다. -> 상속을 사용한다면 피할수 없는 객체지향 프로그래밍의 근본적인 취약성이다.
 * 취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다.
 * 상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다는 사실을 알고 있어야한다.
 * 상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는 데는 용이하지만 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다.
 * 취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다. 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.
 * 상속을 사용하면 부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식 클래스가 영향을 받기 쉬워진다.
 * 상속은 코드의 재사용을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다.
 *
 * 불필요한 인터페이스 상속 문제
 * 자바의 초기 버전에서 상속을 잘못 사용한 사례는 Properties, Stack이 있다.
 * Stack같은 경우 컬렉션 프레임워크 개발자들이 요소의 추가, 삭제 오퍼레이션을 제공하는 Vector를 재사용하기 위해 Stack을 Vector의 자식 클래스로 구현했다.
 * Stack은 Vector를 상속받기 때문에 Stack의 퍼블릭 인터페이스에 Vector의 퍼블릭 인터페이스가 합쳐진다.
 * 따라서 Stack에게 상속된 Vector의 퍼블릭 인터페이스를 이용하면 임의의 위치에서 요소를 추가하거나 삭제할 수 있다.
 * 따라서 맨 마지막 위치에서만 요소를 추가하거나 제거할 수 있도록 허용하는 Stack의 규칙을 쉽게 위반할 수 있다.
 * 문제의 원인은 Stack이 규칙을 무너뜨릴 여지가 있는 위엄한 Vector의 퍼블릭 인터페이스까지도 함께 상속받았기 떄문이다.
 * 인터페이스 설계는 제대로 쓰기엔 쉽게 엉터리로 쓰기엔 얼렵게 만들어야한다.
 * Properties 클래스는 잘못된 유산을 물려받은 클래스중 하나로 키와 값을 보관하는 Map과 유사하지만 키와 값이 오직 String만 가질 수 있다.
 * Properties는 Map의 조상인 Hashtable을 상속 받는데 Java의 제네릭이 도입되기 전에 만들어 졋기 때문에 컴파일러가 키와 값의 타입이 String인지 여부를 체크할 수 있는 방법이 없다.
 * 따라서 Hashtable의 put 메서드를 이용하면 String 타입 이외의 키와 값이라도 Properties에 저장할 수 있다.
 * stack, Properties의 예제는 퍼블릭 인터페이스에 대한 고려 없이 단순히 코드 재사용을 위해 상속을 이용하는 것이 얼마나 위험한지를 잘 보여준다.
 * 단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안된다.
 * - 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
 *
 * 메서드 오버라이딩의 오작용 문제
 * - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
 * 조슈아 블로치는 클래스가 상속되기를 원한다면 상속을 위해 클래스를 설계하고 문서화해야하며, 그렇지 않은 경우 상속을 금지시켜야 한다고 주장한다.
 * 객체지향의 핵심이 구현을 캡술화 하는 것인데 이렇게 내부 구현을 공개하고 문서화하는게 옳은 일인가?? -> 설계는 트레이드오프 활동으로 완벽한 캡슐화를 원한다면 코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용해야한다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
