package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것이다.
 * - 협력에 참여하는 각 객체는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행한다.
 * - 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스 상에 문서화한다.
 * 계약에 의한 설계를 이용하면 오퍼레이션의 시그니처를 구성하는 다양한 요소들을 이용해 협력에 참여하는 객체들이 지켜야 하는 제약 조건을 명시할 수 있다.
 * reserve 매서드는 public 가시성을 가지기 떄문에 외부에서 호출 가능하며, 이 메서드를 사용하기 위해서는 Customer 타입과 int 타입의 인자를 전달해야 한다.
 * 메서드 실행이 성공하면, 반환 타입으로 Reservation 인스턴스를 반환한다는 사실도 알 수 있다.
 * 메서드의 이름과 매개변수의 이름을 통해 오퍼레이션이 클라이언트에게 어떤 것을 제공하려고 하는지를 충분히 설명할 수 있다.
 * 하지만 reserve 메서드를 호출할 때 customer에 null이나, audienceCount의 값으로 음수를 포함한 어떤 정수도 전달할 수 있기 때문에 문제가 된다.
 * -> reserve 메서드는 고객의 예약 정보를 생성하는 것이기 때문에 한 명 이사의 예약자에 대한 예약정보를 생성해야한다(customer가 null이면 안되고, audienceCount 음수면 안된다)
 * 협력하는 클라이언트는 정상적인 상태를 가진 객체와 협력해야 한다.
 * 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것이라고 기대하고, 클라이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상한다.
 * 클라이언트는 메시지 전송 전과 후의 서버의 상태가 정상일 것이라고 기대한다.
 * 사전 조건: 메서드가 호출되기 위해 만족돼야 하는 조건. 메서드의 요구사항을 명시한다(사전 조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무)
 * 사후 조건: 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건. 클라이언트가 사전 조건을 만족시켰다면 메서드느 사후 조건에 명시된 조건을 만족시켜야한다.(사후 조건을 만족시키는 것은 서버의 의무)
 * 불변식: 항상 참이라고 보장되는 서버의 조건. 메서드가 실행되는 도중에는 불변식을 만족시키지 못할 수 있지만, 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이어야한다.
 * 사전조건, 사후조건, 불변식을 기술할 때는 실행 절차를 기술할 필요 없이 상태 변경만을 명시하기 떄문에 코드를 이해하고 분석하기 쉬워진다.
 * -> 클라이언트 개발자는 사전조건에 명시된 조건을 만족하지 않으면 메서드가 실행되지 않을 것을 알고 있다.
 * -> 불변식을 사용하면 클래스의 의미를 쉽게 설명할 수 있고, 클라이언트 개발자가 객체를 더욱 쉽게 예측할 수 있다.
 * -> 사후조건을 믿는다면 객체가 내부적으로 어떤 방식으로 동작하는지 걱정할 필요가 없다.
 *
 * 사전조건
 * 사전조건이란 메서드가 정상적으로 실행되기 위해 만족해야 하는 조건이다. 사전 조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무다.
 * -> 사전조건을 만족시키지 못해 메서드가 실행되지 않을 경우 클라이언트에 버그가 있다는 것을 의미한다.
 * 사전조건은 메서드에 전달된 인자의 정합성을 체크하기 위해 사용된다.
 * -> 사전조건을 정의함으로써 메서드가 잘못된 값을 기반으로 실행되는 것을 방지할 수 있다.
 *
 * 사후조건
 * 사후조건은 메서드의 실행결과가 올바른지를 검사하고, 실행 후에 객체가 유효한 상태로 남아 있는지를 검증한다. -> 사후조건을 통해 메서드를 호출한 후에 어떤 일이 일어났는지를 설명할 수 있다
 * 클라이언트가 사전조건을 만족시켰는데도 서버가 사후조건을 만족시키지 못한다면 서버에 버그가 있음을 의미한다.
 * 사후조건 용도
 * - 인스턴스 변수의 상태가 올바른지를 서술
 * - 메서드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술
 * - 반환값이 올바른지를 서술
 * 사전조건 보다 사후조건이 어려운 이유
 * - 한 메서드 안에서 return 문이 여러번 나올 경우: 모든 return 문마다 결괏값이 올바른지 검증하는 코드를 추가해야한다.
 * - 실행 전과 실행 후의 값을 비교해야 하는 경우: 실행 전의 값이 메서드 실행으로 인해 다른 값으로 변경됐을 수 있기 떄문에 두 값을 비교하기 어렵다.
 *
 * 불변식
 * 불변식은 인스턴스 생명주기 전반에 걸쳐 지켜져야 하는 규칙을 명세한다 -> 불변식은 객체의 내부 상태와 관련이 있다.
 * 특성
 * - 클래스의 모든 인스턴스가 생성된 후에 만족돼야 한다. -> 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다는 것을 의미한다.
 * - 클라이언트에 의해 호출 가능한 모든 메서드에 의해 준수 돼야한다.
 * -> 메서드가 실행되는 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족 시킬 필요는 없지만, 메서드 실행 전과 종료 후에는 항상 불변식을 만족하는 상태가 유지돼야 한다.
 * 불변식은 클래스의 모든 메서드의 사전조건과 사후조건에 추가되는 공통의 조건으로 생각할 수 있다.
 * 불변식은 메서드가 실행되기 전에 사전조건과 함께 실행되며, 메서드가 실행된 후에 사후조건과 함께 실행된다.
 * 만약 불변식을 수작업으로 작성한다면, 모든 메서드에 동일한 불변식을 추가해야하지만, 대부분의 라이브러리들은 불변식을 한 번만 작성하면, 모든 사전조건, 사후조건에 자동으로 합쳐주는 기능을 제공한다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }



  public String Middle(String text){
    /**
     * Contract.OldValue<T> 를 이용하면 메서드 실행전의 상태에도 접근할 수있다.
     * 이 메서드를 이용하면, 실행중에 값이 변경되더라도 사후조건에서 변경 이전의 값을 이용할 수 있게 해준다.
     * text의 값이 메서드 실행 중에 변경이 되기 떄문에 text의 값을 이용하는 사후조건이 저상적으로 체크되지 않는다.
     * Contract.OldValue를 이용하면 메서드를 실행할 때의 text의 값에 접근할 수 있다.
     */
    //Contract.Requires(text != null && text.length >= 2);
    //Contract.Ensures(Contract.Result<string>().Length() < text.Length);
    //Contract.Ensures(Contract.Result<string>().Length() < Contract.OldValue<String>(text).Length);
    text = text.substring(1, text.length()-2);
    return text.trim();
  }
}
