package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법도 있다. 바로 추상 클래스를 이용하는 방법이다.
 * 구체 클래스로 타입을 정의해서 상속받는 방법과 추상 클래스로 타입을 정의해서 상속받는 방법 사이에는 추상화의 정도, 상속을 사용하는 의도 2가지 차이점이 있다.
 * 1) 추상화의 정도
 * 의존하는 대상의 추상화 정도가 다르다.
 * 타입 계층을 구현했던 Phone 클래스 같은 경우 자식 클래스인 NightlyDiscountPhone의 calculateFee 메서드가 부모 클래스인 Phone의 calculateFee 메서드의 구체적인 내부 구현에 강하게 결합된다.
 * -> phone의 내부 구현이 변경될 경우 자식 클래스인 NightlyDiscountPhone도 함께 변경될 가능성이 높다.
 * 추상 클래스인 DiscountPolicy의 경우 자식 클래스인 AmountDiscountPlicy, PercentDiscountPolicy가 DiscountPolicy의 내부 구현이 아닌 추상 메서드의 시그니처에만 의존한다.
 * -> 자식 클래스는 DiscountPolicy가 어떤 식으로 구현돼 있는지는 알 필요 없다. 단지 추상 메서드로 정의된 getDiscountAmount 메서드를 오버라이딩하면 된다는 사실에만 의존해도 무방하다.
 * 부모 클래스와 자식 클래스 모두 추상 메서드인 getDiscountAmount에 의존한다는 것이 중요하다 -> 의존성 역전 원칙의 변형이다,고차원 모듈과 저차원 모듈 모두 추상 메서드인 getDiscountAmount에 의존한다.
 * 또한 DiscountPolicy의 구체 메서드인 calculateDiscountAmount가 추상 메서드 getDiscountAmount를 호출하며 자식 클래스들은 모두 이 추상 메서드의 시그니처를 준수한다.
 * -> 구체적인 메서드가 추상적인 메서드에 의존하기 때문에 의존성 역전 원칙을 따른다고 할 수 있다. 이 설계는 유연한 동시에 변화에 안정적이다.
 * 모든 구체 클래스의 부모 클래스를 항상 추상 클래스로 만들기 위해 노력하라. 의존하는 대상이 더 추상적일수록 결합도는 낮아지고, 변경으로 인한 영향도는 줄어들 것이다.
 * 2) 상속을 사용하는 의도
 * Phone은 상속을 염두에 두고 설계된 것이 아니다. Phone에는 미래의 확장을 위한 어떤 준비도 돼 있지 않다.
 * 그에 반해 DiscountPolicy는 처음부터 상속을 염두에 두고 설계된 클래스다. DiscountPolicy는 추상 클래스이기 때문에 자신의 인스턴스를 직접 생성할 수 없다.
 * DiscountPolicy의 유일한 목적은 자식 클래스를 추가하는 것이다. 이 클래스는 추상 메서드를 제공함으로써 상속 계층을 쉽게 확장할 수 있게 하고 결합도록 인한 부작용을 방지할 수 있는 안전망을 제공한다.
 *
 * 추상 클래스와 인터페이스 결합하기
 * 자바와 C#에서 제공하는 인터페이스를 이용해 타입을 정의하면 다중 상속 문제를 해결할 수 있다.
 * -> 클래스가 구현할 수 있는 인터페이스의 수에는 제한이 없기 때문에 하나의 클래스가 하나 이상의 타입으로 분류 가능하도록 손쉽게 확장할 수 있다.
 * 인터페이스만 사용하는 방법에도 단점이 있다. -> 자바 8이전, C#에서 제공하는 인터페이스는 구현 코드를 포함시킬 수 없기 떄문에 인터페이스만으로는 중복 코드를 제거하기 어렵다.
 * 효과적인 접근 방법은 인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있을 경우에는 추상 클래스를 이용해 코드 중복을 방지하는것이다. (추상 클래스를 사용하는 방식을 골격 구현 추상 클래스라고 부른다)
 * - 외부에 공개한 각각의 중요한 인터페이스와 연관시킨 골격 구현 추상 클래스를 제공함으로써 인터페이스와 추상 클래스의 장점을 결합할 수 있다.
 * - 그렇게 함으로써 인터페이스는 여전히 타입을 정의하지만 골격 구현 클래스는 그것을 구현하는 모든 일을 맡는다.
 * 상속 계층에 대한 제약을 완화시켜 DiscountPolicy 타입으로 분류될 수 있는 객체들이 구현 시에 서로 다른 상속 계층에 속할 수 있도록 만들고 싶다고 가정한다면, 가장 좋은 방법은 인터페이스와 추상 클래스를 결합하는 것이다.
 * DiscountPolicy 타입을 추상 클래스에서 인터페이스로 변경하고 공통 코드를 담을 골격 구현 추상 클래스인 DefaultDiscountPolicy를 추가함으로써 상속 계층이라는 굴레를 벗어날 수 있다.
 * 인터페이스와 추상 클래스를 함께 사용하는 방법은 추상 클래스만 사용하는 방법에 비해 2가지 장점이 이싿.
 * - 다양한 구현 방법이 필요할 경우 새로운 추상 클래스를 추가해서 쉽게 해결할 수 있다.(금액 할인 정책을 더 빠른 속도로 처리, 메모리를 더 적게 차지 방법 모두를 구현해 놓고 상황에 따라 적절한 방법을 선택하게 할 수 있다.)
 * - 이미 부모 클래스가 존재하는 클래스라고 하더라도 인터페이스를 추가함으로써 새로운 타입으로 쉽게 확장할 수 있다.(DiscountPolicy 타입이 추상클래스로 구현돼 있는 경우 이 문제를 해결할 수 있는 유일한 방법은 상속 계층을 다시 조정하는 것뿐)
 * 우리의 설계가 상속 계층에 얽매이지 않는 타입 계층을 요구한다면 인터페이스로 타입을 정의하라. 추상 클래스로 기본 구현을 제공해서 중복 코드를 제거하라
 * 하지만 이런 복잡성이 필요하지 않다면 타입을 정의하기 위해 인터페이스나 추상 클래스 둘 중 하나만 사용하라.
 * 타입의 구현 방법이 단 한가지이거나 단일 상속 계층만으로도 타입 계층을 구현하는데 무리가 없다면 클래스나 추상 클래스를 이용해 타입을 정의하는 것이 더 좋다. 그 외 상황이라면 인터페이스를 이용하는 것을 고려하라
 *
 * 덕 타이핑 사용하기
 * 덕 타이핑은 주로 동적 타입 언어에서 사용하는 방법으로서 덕 테스트를 프로그래밍 언어에 적용한 것이다.
 * 덕 테스트: 어떤 대상의 행동이 오리와 같다면 그것을 오리라는 타입으로 취급해도 무방하다는 뜻("어떤 새가 오리처럼 걷고, 오리처럼 헤엄치며, 오리처럼 꽥꽥 소리를 낸다면 나는 이 새를 오리라고 부를것이다")
 * 객체가 어떤 인터페이스에 정의된 행동을 수행할 수만 있다면 그 객체를 해당 타입으로 분류해도 문제가 없다.
 * SalariedEmployee, HourlyEmployee 클래스는 Employee 인터페이스에 정의된 calculatePay 오퍼레이션과 동일한 시그니처를 가진 퍼블릭 메서드를 포함하고 있다.
 * 따라서 SalariedEmployee, HourlyEmployee 클래스가 동일한 퍼블릭 인터페이스를 공유하기 때문에 동일한 타입으로 취급할 수 있다고 예상할 것이다.
 * 하지만 자바 같은 대부분의 정적 타입 언어에서는 두 클래스를 동일한 타입으로 취급하기 위해서는 코드 상의 타입이 동일하게 선언돼 있어야만 한다.
 * 단순히 동일한 시그니처의 메서드를 포함한다고 해서 같은 타입으로 판단하지 않기 때문에 SalariedEmployee, HourlyEmployee는 Employee 타입이 아니다.
 * SalariedEmployee, HourlyEmployee 인스턴스를 전달하기 위해서는 두 클래스가 Employee 인터페이스를 명시적으로 구현하게 해야한다.
 * 정적 타입 언어에서는 객체의 퍼블릭 인터페이스만으로 타입을 추측하는 것이 불가능하면 모든 요소의 타입이 명시적으로 기술돼 있어야 한다.
 * 반면 런타임에 타입을 결정하는 동적 타입 언어는 특정한 클래스를 상속 받거나 인터페이스를 구현하지 않고도 객체가 수신할 수 있는 메시지의 집합으로 객체의 타입을 결정할 수 있다.
 * 루비같은 동적 타입 언어에서는 명시적으로 동일한 클래스를 상속받거나 동일한 인터페이스를 구현하지 않더라도 시그니처가 동일한 메서드를 가진 클래스는 같은 타입으로 취급할 수 있다.
 * calculatePay(taxRate)라는 행동을 수행할 수 있으면, 이 객체를 Employee라고 부를 수 있는 것이다.
 * 덕 타이핑은 타입이 행동에 대한 것이라는 사실을 강조한다. 두 객체가 동일하게 행동한다면 내부 구현이 어떤 방식이든 상관없다. 타입 관점에서 두 객체는 동일한 타입인 것이다.
 * 인터페이스가 클래스보다 더 유연한 설계를 가능하게 해주는 이유는 클래스가 정의하는 구현이라는 컨텍스트에 독립적인 코드를 작성할 수 있게 해주기 때문이다.
 * 덕 타이핑은 단지 메서드의 시그니처만 동일하면 명시적인 타입 선언이라는 컨텍스트를 제거할 수 있다.
 * 덕 타이핑은 클래스나 인터페이스에 대한 의존성을 메시지에 대한 의존성으로 대체한다. 결과적으로 코드는 낮은 결합도를 유지하고 변경에 유연하게 대응할 수 있다.
 * - 덕 타입은 특정 클래스에 종속되지 않은 퍼블릭 인터페이스다. 여러 클래스를 가로지르는 이런 인터페이스는 클래스에 대한 값비싼 의존을 메시지에 대한 부드러운 의존으로 대치시킨다.
 * C# 같은 경우 닷넷 프레임워크 버전 4에 적용된 dynamic 키워드를 사용하면 덕 타이핑을 흉내 낼 수 있다.
 * dynamic 키워드르 추가하면 calculatePay 메시지에 응답할 수 있는 어떤 객체라도 파라미터로 전달하는 것이 가능해진다. -> calculate 메서드는 클래스나 인터페이스 수준의 결합도를 메시지 수준의 결합도로 낮춘다.
 * 덕 타이핑을 사용하면 메시지 수준으로 결합도를 낮출수 있기 때문에 유연한 설계를 얻을 수 있다. 단, 덕 타이핑을 이용하면 컴파일 시점에 발견할 수 있는 오류를 실행 시점으로 미루게 되기 때문에 설계의 유연성을 얻는 대신 코드의 안전성을 약화시킬 수 있다.
 * 컴파일타임 체크를 통해 타입 안전성을 보장하는 언어도 있다.(c++에서 제네릭 프로그래밍을 구현하는 템플릿)
 * calculate 함수는 첫 번째 파라미터로 임의의 타입 T의 인스턴스를 취하는 함수 템플릿이다. calculate 함수의 첫 번째 파라미터에 대해 덕 타이핑을 지원한다.
 * 첫 번쨰 T 타입인자로 전달되는 객체가 calculate_pay 함수를 구현하고 있는지를 런타임이 아닌 컴파일 시점에 체크할 수 있다는 것이다. 따라서 C++의 템플릿 시스템은 정적 타입 언어의 장점인 타입 안정성까지도 보장해준다.
 * 단, 이경우도 C++의 템플릿은 호출되는 각각의 타입에 대해 calculate 함수의 복사본을 만든다. 내부적으로 SalariedEmployee, HourlyEmployee 를 인자로 받는 개별적인 2개의 함수를 내부적으로 생성한다.
 * 따라서 C++ 템플릿을 사용해서 덕 타이핑의 타입 안전성을 보장하는 대가로 거대한 크기의 프로그램이라는 비효율성을 감수해야만 한다. 설계뿐만 아니라 프로그래밍 언어 역시 트레이드오프의 산물인 것이다.
 */

@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
