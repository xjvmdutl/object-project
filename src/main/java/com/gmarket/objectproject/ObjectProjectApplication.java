package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 상속관계는 is-a 관계라고 부르고, 합성 관계는 has-a 관계라고 부른다.
 * 상속을 이용하면 자식 클래스의 정의에 부모 클래스의 이름을 덧붙이는 것만으로 부모 클래스의 이름을 덧붙이는 것만으로 부모 클래스의 코드를 재사용할 수 있게 된다.
 * 상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아질 수 밖에 없다.
 * 합성은 구현에 의존하지 않는다는 점에서 상속과 다르다.-> 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다.
 * 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있게 된다.
 * 상속관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계다.
 * 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 합성 관계는 실행 시점에 동적으로 변경할 수 있기 떄문에 이 차이점은 중요하다.
 * 상속과 합성은 재사용의 대상이 다르다. -> 상속은 부모 클래스 안에 구현된 코드 자체를 재사용하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다.
 * 따라서 상속말고 합성을 이용하면 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다. -> 클래스 사이 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있다.\
 *
 * 상속을 합성으로 변경하기
 * 상속을 3가지 문제
 * - 불필요한 인터페이스 상속 문제: 자식 클래스에게는 부적접한 부모 클래스의 오퍼레이션이 상속되기 때문에 자식 클래스 인스턴스의 상태가 불안정해지는 문제(Properties, Stack)
 * - 메서드 오버라이딩의 오작용 문제: 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때 자식 클래스가 부모 클래스의 메서드 호출 방법에 영향을 받는 문제(hashSet을 상속받는 InstrumentedHashSet)
 * - 부모 클래스와 자식 클래스의 동시 수정 문제: 부모 클래스와 자식 클래스 사이의 개념적인 결합으로 인해 부모 클래스를 변경할 때 자식 클래스도 함께 변경해야 하는 문제(playlist를 상속받은 personalPlaylist)
 *
 * 불필요한 인터페이스 상속 문제
 *
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
