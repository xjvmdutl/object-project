package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 일관성 있는 설계를 만드는 데 가장 훌룡한 조언
 * - 다양한 설계 경험을 익혀라
 * - 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해봐라
 * 협력을 일관성 있게 만들기 위한 기본 지침
 * - 변하는 개념을 변하지 않는 개념으로부터 분리하라
 * - 변하는 개념을 캡슐화하라
 *
 * 조건 로직 대 객체 탐색
 * 이전(4장)에서 보았던 조건 탐색 로직이 안좋은 이유를 살펴보자
 * 이 설계가 나쁜 이유는 변경의 주기가 서로 다른 코드가 한 클래스 안에 뭉쳐있기 때문이다. 또한 새로운 할인 정책이나 할인 조건을 추가하기 위해서는 기존 코드의 내부를 수정해야 하기 때문에 오류가 발생할 확률이 높아진다.
 * 절차지향 프로그램에서 변경을 처리하는 전통적인 방법은 이처럼 조건문의 분기를 추가하거나 개별 분기 로직을 수정하는 것이다.
 * 객체지향에서 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것이다.
 * 다형성은 바로 이런 조건 로직을 객체사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법이다.
 * - 변하는 개념을 변하지 않는 개념으로부터 분리하라
 * 할인 정책의 구체적인 종류는 메시지를 수신한 객체의 타입에 따라 달라지며, 실행할 메서드를 결정하는 것은 순전히 메시지를 수신한 객체의 책임이다.
 * 객체지향적인 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다. 조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다란 클래스를 더 작은 클래스들로 분리해야 한다.
 * 클래스를 분리하기 위해 어떤 기준을 따르는 것이 좋을까? 가장 중요한 것은 변경의 이유와 주기이다.
 * 클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고, 클래스 안의 모든 코드는 함께 변경돼야 한다. -> 단일 책임 원칙을 따르도록 클래스를 분리해야 한다.
 * 큰 메서드 안에 뭉쳐있던 조건 로직들을 변경의 압력에 맞춰 작은 클래스들로 분리하고 나면 인스턴스들 사이의 협력 패턴에 일관성을 부여하기가 더 쉬워진다.
 * 유사한 행동을 수행하는 작은 클래스들이 자연스럽게 역할이라는 추상화로 묶이게 되고 역할 사이에서 이뤄지는 협력 방식이 전체 설계의 일관성을 유지할 수 있게 이끌어주기 때문이다.
 * 이 설계는 새로운 할인 정책과 할인 조건을 추가하기도 용이하다.
 * - 변하는 개념을 캡슐화하라
 * 이전 설계에서는 타입을 체크하는 하나하나의 조건문이 개별적인 변경이었다는 점을 기억하라. 우리는 각 조건문을 개별적인 객체로 분리했고 이 객체들과 일관성 있게 협력하기 위해 타입 계층을 구성했다.
 * 그리고 이 타입 계층을 클라이언트로부터 분리하기 위해 역할을 도입하고 최종적으로 역할을 추상 클래스 인터페이스로 구현했다 -> 결과적으로 변하는 개념을 별도의 서브타입으로 분리한 후, 이 서브타입들을 클라이언트로부터 캡슐화한 것이다.
 * 핵심은 훌료한 추상화를 찾아 추상화에 의존하도록 만드는 것이다. 추상화에 대한 의존은 결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다. 따라서 선택하는 추상화의 품질이 캡슐화의 품질을 결정한다.
 * - 구성 요소를 캡슐화하는 실행 지침은 객체지향의 핵심 덕목 중 하나다(시스템을 책임을 캡슐화한 섬들로 분리하고 그 섬들 간의 결합도를 제한하라).
 * - 이 실행 지침이 드러나는 또다른 주제가 패턴이다. 패턴은 매우 빈번하게 요소들이 관계를 맺을 수 있는 대상을 추상적인 기반 타입으로 제한한다.
 *
 * 캡슐화 다시 살펴보기
 * 데이터 은닉이란 오직 외부에 공개된 메서드를 통해서만 객체의 내부에 접근할 수 있게 제한함으로써 객체 내부의 상태 구현을 숨기는 기법을 가리킨다
 * -> 클래스의 모든 인스턴스 변수는 private로 선언해야 하고 오직 해당 클래스의 메서드만이 인스턴스 변수에 접근할 수 있어야 한다는 것이다.
 * - 설계에서 무엇이 변화될 수 있는지 고려하라. 설계에 변경을 강요하는 것이 무엇인지에 대해 고려하기보다는 재설계 없이 변경할 수 있는 것이 무엇인지 고려하라
 * GOF의 조언에 따르면 캡슐화란 단순히 데이터를 감추는 것이 아니다. 소프트웨어 안에서 변할 수 있는 모든 개념을 감추는 것이다.
 * - 캡슐화란 변하는 어떤 것이든 감추는 것이다.
 * 캡슐화의 가장 대표적인 예는 객체의 퍼블릭 인터페이스와 구현을 분리하는 것이다. -> 자주 변경되는 내부 구현을 안정적인 퍼블릭 인터페이스 뒤로 숨겨야한다.
 * 캡슐화란 단순히 데이터를 감추는 것이 아니다. 소프트웨어 안에서 변할 수 있는 어떤 개념이라도 감추는 것이다.
 * - 데이터 캡슐화: 클래스의 인스턴스 변수가 private이다. 이 속성에 접근할 수 있는 유일한 방법은 메서드를 이용하는 것뿐이다. 클래스는 내부에 관하는 데이터를 캡슐화한다.
 * - 메서드 캡슐화: 메서드의 가시성이 protected이다. 클래스의 외부에서는 이 메서드에 직접 접근할 수없고 클래스 내부와 서브클래스에서만 접근이 가능하다. 클래스 외부에 영향을 미치지 않고 메서드를 수정할 수 있으며, 클래스의 내부 행동을 캡슐화하고 있는것이다.
 * - 객체 캡슐화: 클래스가 다른 인스턴스 변수를 포함한다. 이 인스턴스 변수는 private 가시성을 가지기 때문에 두 클래스 사이의 관계를 변경하더라도 외부에는 영향을 미치지 않는다. 객체와 객체사이의 관계를 캡슐화하며 이 객체 캡슐화가 합성을 의미한다.
 * - 서브타입 캡슐화: 기반 클래스를 상속한다. 협력하는 클래스는 부모 클래스는 알고있지만 자식 클래스는 알지 못한다. 그러나 실제로 실행 시점에는 이 클래스들의 인스턴스와 협력할 수 있다. 이것은 부모 클래스와의 추상적인 관계가 자식 클래스의 존재를 감추기 때문이다.
 *                서브타입의 종류를 캡슐화하고 있는 것이다. 서브타입 캡슐화가 다형성의 기반이 된다.
 * 코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다. 일반적으로 데이터 캡슐화와 메서드 캡슐화는 개별 객체에 대한 변경을 관리하기 위해 사용하고 객체 캡슐화와 서브타입 캡슐화는 협력에 참여하는 객체들의 관계에 대한 변경을 관리하기 위해 사용한다.
 * 변경을 캡슐화할 수 있는 다양한 방법이 존재하지만 협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 서브타입 캡슐화와 객체 캡슐화를 조합하는 것이다. 서브타입 캡슐화는 인터페이스 상속을 사용하고 객체 캡슐화는 합성을 사용한다.
 * 서브타입 캡슐화와 객체 캡슐화를 적용하는 방법
 * - 변하는 부분을 분리해서 타입 계층을 만든다: 변하지 않는 부분으로부터 변하는 부분을 분리한다. 변하는 부분들의 공통적인 행동을 추상 클래스나 인터페이스로 추상화한 후, 변하는 부분들이 이 추상 클래스나 인터페이스를 상속받게 만든다. 이제 변하는 부분은 변하지 않는 부분의 서브타입이 된다.
 * - 변하지 않는 부분의 일부로 타입 계층을 합성한다: 타입 계층을 변하지 않는 부분에 합성한다. 변하지 않는 부분에서 변경되는 구체적인 사항에 결합돼서는 안된다. 의존성 주입과 같이 결합도를 느슨하게 유지할 수 있는 방법을 이용해 오직 추상화에만 의존하게 만든다. 이제 변하지 않는 부분은 변하는 부분의 구체적인 종류에 대해서는 알지 못할 것이다. 변경이 캡슐화된 것이다.
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
