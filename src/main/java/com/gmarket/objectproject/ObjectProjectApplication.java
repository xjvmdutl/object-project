package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계를 의미한다.
 * 하지만 유연하고 재사용 가능한 설계가 항상 좋은 것은 아니다. -> 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함의 미덕을 버리게될 가능성이 높다.
 * 유연한 설계의 이면에는 복잡한 설계라는 의미가 숨어있으며, 객관적으로 설계를 판단하기 어렵게 만든다.
 * 변경은 예상이 아니라 현실이어야 하며, 미래에 변경이 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다. => 아직 일어나지 않은 변경은 변경이 아니다.
 * 유연성은 항상 복잡성을 수반한다. 유연하지 않은 설계는 단순하고 명확하다.
 * 객체지향에 입문한 개발자들이 가장 이해하기 어려워하는 부분이 바로 코드상에 표현도니 정적인 클래스의 구조와 실행 시점의 동적인 객체 구조가 다르다는 사실이다.
 * 특정 시점의 객체 구조를 파악하는 유일한 방법은 클래스를 사용하는 클라이언트 코드 내에서 객체를 생성하거나 변경하는 부분을 직접 살펴보는것 뿐이다.
 * 설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다. 유연한 설계를 단순하고 명확하게 만드는 유일한 방법은 사람들 간의 긴밀한 커뮤니케이션뿐이다.
 * 불필요한 유연성은 불필요한 복잡성을 낳는다. 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라.
 *
 * 협력과 책임이 중요하다.
 * 설계를 유연하게 만들기 위해서는 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요하다.
 * 설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야한다.
 * 다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 함께 사라진다.
 * - 객체들이 메시지 전송자의 관점에서 동일한 책임을 수행하는지 여부를 판단할 수 없다면 공통의 추상화를 도출할 수 없다.
 * - 동일한 역할을 통해 객체들을 대체 가능하게 만들지 않았다면 협력에 참여하는 객체들을 교체할 필요가 없다.
 * 초보자가 자주 저지르는 실수는 객체의 역할과 책임이 자리 잡기전 성급하게 객체 생성에 집중하는 것이다. -> 객체 생성과 관련된 불필요한 세부사항에 객체를 결합시킨다.
 * 객체를 생성할 책임을 담당할 객체나 객체 생성 메커니즘을 결정하는 시점은 책임 할당의 마지막 단계로 미뤄야만 한다. -> 중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선이다.
 * 책임의 불균형이 심화되고 있는 상태에서 객체의 생성 책임을 지우는 것은 설계를 하부의 특정한 메커니즘에 종속적으로 만들 확률이 높다. 불필요한 싱글톤 패턴은 객체 생성에 관해 너무 이른 시기에 고민하고 결정할 때 도입되는 경향이 있다.
 * 핵심은 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다는 것이다.
 * 의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다. 따라서 역할, 책임, 협력에 먼저 집중하라
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
