package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 데이터 중심의 설계가 캡슐화 위반, 높은 결합도, 낮은 응집도 문제를 야기한다.
 *
 * 캡슐화 위반
 * 접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.
 * Movie 객체가 캡슐화를 위반하게 된 원인은 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 떄문이다.
 * 객체에게 중요한 것은 책임으로 구현을 캡슐화할 수 있는 적절한 책임은 협력이라는 문맥을 고려할 때만 얻을 수 있다.
 * 설계할 때 협력에 대한 고민을 하지 않으면 과도한 접근자와 수정자를 가지게 되는 경향이 있다.
 * 객체가 사용될 문맥을 추측할 수 밖에 없는 경우 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는 것이다.
 * 이처럼 접근자와 수정자에 과도하게 의존하는 설계방식을 추측에 의한 설계 전략이라고 부른다.
 * -> 이 전략은 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수 밖에 없으며 캡슐화의 원칙을 위반하는 변경에 취약한 설계를 가지게 되는것이다
 *
 * 높은 결합도
 * 데이터 중심의 설계는 접근자, 수정자를 통해 내부 구현을 인터페이스의 일부로 만들기 때문에 캡슐화를 위반한다
 * 객체의 내부 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미하며 단지 객체 내부 구현을 변경했음에도 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야한다.
 * 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어로직이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다.
 * -> 데이터 객체를 변경하면 제어 객체를 함께 변경할 수 밖에 없다.
 * 데이터 중심 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 어떤 변경이라도 발생하고 나면 시스템 전체가 요동칠 수 밖에 없다.
 *
 * 낮은 응집도
 * 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.
 * 낮은 응집도의 문제점
 * - 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다.
 * - 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다. -> 응집도가 낮을 경우 다른 모듈에 위치해야 할 책임의 일부가 엉뚱한 곳에 위치하게 되기 때문이다.
 * 어떤 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 하는 것은 설계의 응집도가 낮다는 증거이다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
