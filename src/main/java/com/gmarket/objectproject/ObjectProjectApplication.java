package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 타입은 다양한 방법으로 구현할 수 있다. 사실 타입의 개념을 이해하는 데 가장 큰 걸림돌은 타입을 구현하는 방법이 다양하다는 점이다.
 * 타입 계층은 타입보다 상황이 더 복잡한데, 다양한 방식으로 구현된 타입들을 하나의 타입 계층 안에 조합할 수 있기 때문이다.
 * - 타입 계층은 동일한 메시지에 행동 호환성을 전제로 하기 때문에 여기서 언급하는 모든 방법은 타입 계층을 구현하는 방법인 동시에 다형성을 구현하는 방법이기도 하다.
 * - 여기서 제시하는 방법을 이용해 타입과 타입 계층을 구현한다고 해서 서브타이핑 관계가 보장되는 것은 아니다.
 *   올바른 타입 계층이 되기 위해서는 서브타입이 슈퍼타입을 대체할 수 있도록 리스코프 치환 원칙을 준수해야한다. 리스코프 치환 원칙은 특정한 구현 방법에 의해 보장될 수 없기 때문에 클라이언트 관점에서 타입을 동일하게 다룰 수 있도록 의미적으로 행동 호환성을 보장하는 것은 전적으로 우리 책임이다.
 *
 * 클래스를 이용한 타입 계층 구현
 * 타입은 객체의 퍼블릭 인터페이스를 가리키기 때문에 결과적으로 클래스는 객체의 타입과 구현을 동시에 정의하는 것과 같다. 이것이 객체지향 언어에서 클래스를 사용자 정의 타입이라고 부르는 이유다.
 * 타입을 구현할 수 있는 방법이 단 한가지만 존재하는 경우에는 타입과 클래스를 동일하게 취급해도 무방하다. 타입을 구현할 수 있는 다양한 방법이 존재하는 순간부터는 클래스와 타입은 갈라지기 시작한다.
 * 퍼블릭 인터페이스를 유지하면서 새로운 구현을 가진 객쳋를 추가할 수 있는 가장 간단한 방법은 상속을 이용하는 것이다. 상속을 이용하면 자식 클래스가 부모 클래스의 구현뿐만 아니라 퍼블릭 인터페이스도 물려받을 수 있기 때문에 타입 계층을 쉽게 구현할 수 있다.
 * 하지만 상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시키기 때문에 구체 클래스를 상속 받는것은 피해야 한다.
 *
 * 인터페이스를 이용한 타입 계층 구현
 * - 여러 클래스가 동일한 타입을 구현할 수 있다.
 * - 하나의 클래스가 여러 타입을 구현할 수 있다.
 * 인터페이스를 이용해 타입을 정의하고 클래스를 이용해 객체를 구현하면 클래스 상속을 사용하지 않고도 타입 계층을 구현할 수 있다.
 * 하나의 객체가 여러 타입을 가질 수 있고 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있다. 즉 객체의 구현은 다를지라도 인터페이스는 같을 수 있다는 의미다.
 * 클래스도 객체가 만족할 수 있는 오퍼레이션을 정의하고 있으므로 타입을 정의하는 것이기도 하다. 그래서 객체가 클래스의 인터페이스라고 말할 때 객체는 클래스가 정의하고 있는 인터페이스를 지원한다는 뜻을 내포한다.
 * 클래스와 타입의 차이점을 이해하는 것은 설계 관점에서 매우 중요하다. 타입은 동일한 퍼블릭 인터페이스를 가진 객체들의 범주다.
 * 클래스는 타입에 속하는 객체들을 구현하기 위한 구현 메커니즘이다.
 * 타입이 식별된 후에 타입에 속하는 객체를 구현하기 위해 클래스를 사용하는 것이다.
 * 중요한 것은 객체가 외부에 제공하는 행동, 즉 타입을 중심으로 객체들의 계층을 설계하는 것이다.
 * 타입이 아니라 클래스를 강조하면 객체의 퍼블릭 인터페이스가 아닌 세부 구현에 결합된 협력 관계를 낳게 된다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
