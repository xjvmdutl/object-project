package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 캡슐화
 * 상태와 행동을 하나의 객체로 모으는 이유는 객체의 내부 구현(변경될 가능성이 높은 어느 것)을 외부로부터 감추기 위해서이다.
 * 객체지향이 강력한 이유는 한곳에서 일어난 변경이 전체 시스템에 영향이 가지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공하기 떄문이다.
 * 객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다.
 * 변경될 가능성이 높은 부분을 구현이라고 부르고, 상대적으로 안정적인 부분을 인터페이스라고 부른다.
 * 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것
 * 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한종류이다 -> 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는것이다.
 * 설계가 필요한 이유는 요구사항일 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 영향을 통제 할 수 있기 때문이다(설계의 품질은 캡슐화를 기준 삼을 수 있다)
 *
 * 응집도와 결합도
 * 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.
 * -> 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.
 * -> 모듈 내의 요소들이 서로 다른 목적을 추구한다면 낮은 응집도를 가진다.
 * 객체지향에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.
 * 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도이다.
 * -> 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다.
 * -> 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다.
 * 객체지향에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.
 * 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다. -> 응집도와 결합도는 변경과 관련된 것이다.
 * 높은 응집도와 낮은 결합도를 추구해야하는 이유는 설계를 변경하기 쉽게 만들기 때문이다
 * -> 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다
 * 응집도가 높은 설계에서는 하나의 요구사항을 반영하기 위해 하나의 모듈만을 수정하면 되지만 응집도가 낮은 설계에서는 하나의 원인에 의해 변경해야하는 부분이 다수의 모듈에 분산돼 있기 떄문에 여러 모듈을 동시에 수정해야한다
 * 응집도가 높을수록 변경의 대상과 범위가 명확해 지기 때문에 코드를 변경하기 쉬워진다
 * -> 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.
 * 낮은 결합도를 가진 설계에서는 모듈 A를 변경했을 때 오직 하나의 모듈만 영향을 받지만 높은 결합도를 가진 설계에서는 모듈 A를 변경했을 때 여러개의 모듈을 동시에 변경해야한다
 * 내부 구현을 변경했을 떄 이것이 다른 모듈에 영향을 미치는 경우에는 두 모듈사이에 결합도가 높다고 표현하고 퍼블릭 인터페이스만 수정했을 떄만 다른 모듈에 영향을 끼치는 경우를 결합도가 낮다고 표현한다 -> 인터페이스에 대해 프로그래밍 하라
 * 일반적으로 변경될 확률이 매우 적은 안정적인 모듈(String, ArrayList)에 의존하는 것은 아무런 문제가 되지 않는다. <-> 직접 작성한 코드는 불안정하며 변경될 확률이 높기 때문에 낮은 결합도를 유지하려고 노력해야한다.
 * 캡슐화를 지키면 모듈안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다. 캡슐화를 위반하면 모듈 안의 응집도는 낮아지고 모듈 사이의 결합도는 높아진다. -> 응집도와 결합도를 고려하기 전에 캡슐화를 먼저 고려하자
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
