package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 상속을 이용하면 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함시킬 수 있다(데이터 관점 상속)
 * 데이터뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함시킬 수 있다.(행동 관점의 상속)
 * 상속의 목적은 코드 재사용이 아닌 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.
 * 타입 계층에 대한 고민 없이 코드를 재사용하기 위해 상속을 사용하면 이해하기 어렵고 유지보수하기 버거운 코드가 만들어질 확률이 높다. -> 상속이 무엇이고 언제 사용하는지를 이해해야 ㅎ나다.
 *
 * 데이터 관점의 상속
 * 상속을 인스턴스 관점에서 바라볼 때는 개념적으로 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 포함되는 것으로 생각하는 것이 유용하다.
 * 인스턴스를 참조하는 lecture는 gradeLecture의 인스턴스를 가리키기 떄문에 특별한 방법을 사용하지 않으면 GradeLecture안에 포함된 Lecture의 인스턴스에 직접 접근할 수 없다.
 * lecture -> GradeLecture(grades=["A", "B", "C", "D", "F"] -> Lecture(title = "객체지향 프로그래밍", pass = 70, scores = [81, 95, 75, 50, 45])
 * 자식 클래스의 인스턴스에서 부모 클래스의 인스턴스로 접근 가능한 링크가 존재하는 위 모습처럼 생각해도 무방하다.
 * 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다.
 * 따라서 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 되는 것이다.
 *
 * 행동 관점의 상속
 * 행동 관점의 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다.
 * 부모 크랠스에 정의된 어떤 메서드가 자식 클래스에 포함될지는 언어의 종류와 접근 제어자의 의미에 따라 다르지만 공통적으로 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스를 포함한다.
 * -> 외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에게도 전송할 수 있다.
 * 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐진다고 표현했지만 실제로 클래스의 코드를 합치거나 복사하는 작업이 수행되는 것은 아니다.
 * -> 런타임에 시스템이 자식 클래스에 정의되지 않는 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.
 * 이처럼 해동 관점에서 상속과 다형성의 기본적인 개념을 이해하기 위해서는 상속관계로 연결된 클래스 사이의 메서드 탐색 과정을 이해하는 것이 가장 중요하다.
 * 메서드의 경우에는 동일한 클래스의 인스턴스끼리 공유가 가능하기 떄문에 클래스는 한번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적이다.
 * 자신의 위치를 가리키는 class 라는 포인터를 가지며, 이 포인터를 이용해 자신의 클래스 정보에 접근할 수 있다.
 * 부모 클래스의 위치를 가리키는 parent라는 포인터를 가지며, 이 포인터를 이용하면 클래스의 상속 계층을 따라 부모 클래스의 정의로 이동하는 것이 가능하다.
 * 메시지를 수신한 객체는 class 포인터로 연결된 자신의 클래스에서 적절한 메서드가 존재하는지 찾는데 만약 메서드가 존재하지 않는다면 parent 포인터를 따라 부모 클래스를 차례대로 훑어가면서 적절한 메서드가 존재하는지 검색한다.
 * 각 객체에 포함된 class 포인터와 클래스에 포함된 parent 포인터를 조합하면 현재 인스턴스의 클래스에서 최상위 부모 클래스에 이르기까지 모든 부모 클래스에 접근하는 것이 가능하다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
