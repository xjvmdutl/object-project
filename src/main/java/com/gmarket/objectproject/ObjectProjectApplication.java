package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 객체지향 시스템을 실행할 메서드 선택 규칙
 * - 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다. -> 존재하면 메서드를 실행하고 탐색 종료
 * - 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속한다. -> 적합한 메서드를 찾을떄까지 상속 계층을 따라 올라가면 계속된다.
 * - 상속 계층의 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.
 * 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정한다.
 * 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄지며 메서드 탐색이 종료되는 순간 self  참조는 자동으로 소멸된다.(정적 타입 언어 -> this, 동적 타입 언어 -> self)
 * 메서드 탐색은 자식 클래스에서 부모 클래스의 방향으로 진행된다. -> 항상 자식 클래스의 메서드가 부모 클래스의 메서드보다 먼저 탐색되기 때문에 자식 클래스에 선언된 메서드가 부모 클래스의 메서드보다 더 높은 우선순위를 가진다.
 * 동적 메서드 탐색의 원리
 * 1) 자동적인 메서지 위임: 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층을 따라 부모 클래스에게 처리를 위임한다. 클래스 사이의 위임은 프로그래머의 개입 없이 상속 계층을 따라 자동으로 이뤄진다.
 * 2) 동적인 문맥을 이용하여 메서드 탐색: 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 실행시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다.
 * 메시지가 처리되는 문맥을 이해하기 위해서는 정적인 코드를 분석하는 것만으로 충분하지 않으며, 런타임에 실제로 메시지를 수신한 객체가 어떤 타입인지를 추적해야 한다.
 *
 * 자동적인 메시지 위임
 * 상속 계층은 메시지를 수신한 객체가 자신이 이해할 수 없느 메시지를 부모 클래스에게 전달하기 위한 물리적인 경로를 저으이하는 것으로 볼 수 있다.
 * 상속 계층 안의 클래스는 메시지를 처리할 방법을 잘지 못할 경우 메시지에 대한 처리를 부모 클래스에게 위임한다.
 * 적절한 메서드를 찾을 때까지 상속 계층을 따라 부모 클래스로 처리가 위임된다.
 * 상속을 이용할 경우 프로그래머가 메시지 위임과 관련된 코드를 명시적으로 작성할 필요가 없음에 주목하자
 * 메시지는 상속 계층을 따라 부모 클래스에게 자동으로 위임된다. -> 이런 관점에서 상속 계층을 정의하는 것은 메서드 탐색 경로를 정의하는 것과 동일하다.
 * 일부 언어들은 상속이 아닌 다른 방법을 이용해 메시지를 자동으로 위임할 수 있는 메커니즘을 제공하기도 한다(루비의 모듈, 스칼라의 트레이드..)
 * -> 여기서는 메시지 위임 과정을 상속을 사용하였지만, 자동적인 메시지 위임을 지원하는 방법은 언어에 따라 다를 수 있다는 사실을 기억하자.
 * 자식 클래스에서 부모 클래스의 방향으로 자동으로 메시지 처리가 위임되기 때문에 자식 클래스에서 어떤 메서드를 구현하고 있느냐에 따라 부모 클래스에 구현된 메서드의 운명이 결정되기도 한다.
 * 메서드 오버라이딩은 자식 클래스의 메서드가 동일한 시그니처를 가진 부모 클래스의 메서드보다 먼저 탐색되기 때문에 벌어지는 현상이다.
 * 동일한 시그니처를 가지는 자식 클래스의 메서드는 부모 클래스의 메서드를 감추지만, 이름만 같고 시그니처가 완전히 동일하지 않은 메서드들은 상속 계층에 걸쳐 사이좋게 공존할 수도 있다 -> 메서드 오버로딩
 *
 * 동적인 문
 * 메시지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다는 점이 중요하다. 그리고 이 동적인 문맥을 결정하는 것은 바로 메시지를 수신한 객체를 가리키는 self 참조다.
 * self 참조가 Leture의 인스턴스를 가리키고 있다면 메서드를 탐색할 문맥은 Leture 클래스에서 시작해서 Object 클래스에서 종료되는 상속 계층이 된다.
 * 동일한 코드라고 해서 self 참조가 가리키는 객체가 무엇인지에 따라 메서드 탐색을 위한 상속 계층의 범위가 동적으로 변한다.
 * 따라서 self 참조가 가리키는 객체의 타입을 변경함으로써 객체가 실행될 문맥을 동적으로 바꿀 수 있다.
 * self 참조가 동적 문맥을 결정한다는 사실은 종종 어떤 메서드가 실행될지를 예상하기 어렵게 만든다.
 * 대표적인 경우가 자신에게 다시 메시지를 전송하는 self 전송이다.
 *
 * 이해할 수 없는 메시지
 * 상속 계층의 정상에 오고 나서야 자신이 메시지를 처리할 수 없다는 사실을 알게 됐다면 어떻게 할까?
 * 이해할 수 없는 메시지를 처리하는 방법은 프로그래밍 언어가 정적 타입 언어에 속하는지, 동적 타입 언어에 속하는지에 따라 달라진다.
 * - 정적 타입 언어와 이해할 수 없는 메시지
 * 정적 타입 언어에서는 코드를 컴파일할  떄 상속 계층 안의 클래스들이 메시지를 이해할 수 있는지 여부를 판단한다.-> 상속 계층 전체를 탐색한 후에도 메시지를 처리할 수 있는 메서드를 발견하지 못했다면 컴파일 에러를 발생시킨다.
 * Object 클래스 까지 메시지를 이해할 수 없다면 더 이상 부모 클래스가 존재하지 않기 때문에 컴파일 에러를 발생시켜 메시지를 처리할 수 없다는 사실을 프로그래머에게 알린다.
 * - 동적 타입 언어와 이해할 수 없는 메시지
 * 메시지를 수신한 객체의 클래스부터 부모 클래스의 방향으로 메서드를 탐색한다. 차이점은 동적 타입 언어에서는 컴파일 단계가 존재하지 않기 때문에 실제로 코드를 실행해보기 전에는 메시지 처리 가능 여부를 판단할 수 없다는 점이다.
 * 몇 동적 타입 언어에서는 최상위 클래스까지 메서드 탐색 후 메서드를 처리할 수 없다는 사실을 발견하면, self 참조가 가리키는 현재 객체에게 메시지를 이해할 수 없다는 메시지를 전송한다.
 * 스몰토크에서는 doesNotUnderstand, 루비의 경우 method_missing 메시지를 전송한다.
 * 이 메시지들 역시 보통의 메시지처럼 self 참조가 가리키는 객체의 클래스에서부터 시작해서 상속 계층을 거슬러 올라가며 메서드를 탐색한다. -> 만약 상속 계층 모두 메시지를 처리할 수 없다면 메서드 탐색은 다시 최상위 클래스에 이르게 되고 최종적 예외가 발생한다.
 * 스몰토크의 최상위 클래스인 object는 doesNotUnderstand 메시지에 대한 기본처리로 MessageNotUnderstood 예외를 던지고, 루비의 최상위 클래스인 Object는 method_missing 메시지에 대한 기본처리로 NoMethodError 예외를 던진다.
 * doesNotUnderstand, method_missing 메시지에 응답할 수 있는 메서드를 구현하는 방식으로 자신의 인터페이스에 정의되지 않은 메시지를 처리하는 것이 가능해진다.
 * 이해할 수 없는 메시지를 처리할 수 있는 동적 타입 언어는 좀 더 순수한 관점에서 객체지향 패러다임을 구현했다고 볼 수 있다.
 * -> 협력을 위해 메시지를 전송하는 객체는 메시지를 수신한 객체의 내부 구현에 대해서 알지 못한다.
 * -> 단지 객체가 메시지를 처리할 수 있다고 믿고 메시지를 전송할 뿐이다.
 * -> 객체가 해당 메서드를 구현하던 말건, method_missing 메서드를 재정의하건 말건 클라이언트는 단지 전송한 메시지가 성공적으로 처리됐다는 사실만 알 수 있다.
 * 동적 타입 언어는 이해할 수 없는 메시지를 처리할 수 있는 능력을 가짐으로써 메시지가 선언된 인터페이스와 메서드가 정의된 구현을 분리할 수 있다. -> 메시지 전송자는 자신이 원하는 메시지를 전송, 메시지 수신자는 스스로의 판단에 따라 메시지를 처리한다.
 * 이것이 메시지를 기반으로 협력하는 자율적인 객체라는 순수한 객체지향의 이상에 가까운 것이다
 * 그러나 동적 타입 언어의 이러한 동적인 특성, 유연성은 코드를 이해하고 수정하기 어렵게 만들뿐만 아니라 디버깅 과정을 복잡하게 만들기도 한다.
 * 정적타입 언어에는 이런 유연성이 부족하지만 좀 더 안정적이다. 모든 메시지는 컴파일 타임에 확인되고 이해할 수 없는 메시지는 컴파일 에러로 이어진다.
 * -> 이해할 수 없는 메시지를 처리할 수 있는 유연성은 잃게 되지만 실행 시점에 오류가 발생할 가능성을 줄임으로써 프로그램이 좀 더 안정적으로 실행될 수 있는 것이다.
 * 업캐스팅과 동적 바인딩이라는 언어적인 특성과 실행 시점에 적절한 메서드를 선택하는 동적 메서드 탐색을 혼합해서 동일한 코드를 이용해 서로 다른 메서드를 실행하는 것이 가능해진다.
 * 객체지향 프로그래밍 언어는 이와 같은 메커니즘의 도움을 받아 동일한 메시지에 대해 서로 다른 메서드를 실행할 수 있는 다형성을 구현하는 것이다.
 *
 * self 대 super
 * self 참조는 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행 시점에 결정한다.
 * 자식 클래스에서 부모 클래스의 구현을 재사용해야 하는 경우가 있는데 대부분 객체지향 언어에서는 자식 클래스에서 부모 크랠스의 인스턴스 변수나 메서드에 접근하기 위해 사용할 수 있는 super 참조라는 내부 변수를 제공한다.
 * 대부분의 사람들은 super.evalute() 라는 문장이 단순 부모 클래스의 evaluate 메서드를 호출한다고 생각하지만, super.evalute() 메서드는 부모 클래스가 아니라 더 상위에 위치한 조상 클래스의 메서드일 수도 있다.
 * 사실 super 참조의 용도는 부모 클래스에 정의된 메서드를 실해하기 위한 것이 아닌 "지금 이 클래스의 부모클래스에서부터 메서드 탐색을 시작하세요"이다.
 * 만약 부모 클래스에서 원하는 메서드를 찾지 못한다면 더 상위의 부모 클래스로 이동하면서 메서드가 존재하는지 검사한다.
 * 이것은 super 참조를 통해 실행하고자 하는 메서드가 반드시 부모 클래스에 위치하지 않아도 되는 유연성을 제공하며, 그 메서드가 조상 클래스 어딘가에 있기만 하면 성곡적으로 탐색될 것이기 때문이다.
 * 부모 클래스에서 메서드 탐색을 시작한다는 것은 그 클래스의 조상 어딘가에 그 메서드가 정의돼 있기만 하며 실행할 수 있다는 것을 의미한다.
 * 이처럼 super 참조를 통해 메시지를 전송하는 것은 마치 부모 클래스의 인스턴스에게 메시지를 전송하는 것처럼 보이기 떄문이 이를 super 전송이라고 불느다.
 * (java -> super, c# -> base, c++ -> "::" 연산자 조합)
 * self 전송이 메시지를 수신하는 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정하는 데 비해 super 전송은 항상 메시지를 전송하는 클래스의 부모 클래스에서부터 시작된다.
 * self 전송에서 메시지 탐색을 시작하는 클래스는 미정이지만, super 전송에서는 미리 정해진다는 것이다.
 * self 전송의 경우 메서드 탐색을 시작할 클래스를 반드시 실행 시점에 동적으로 결정해야 하지만, super 전송의 경우에는 컴파일 시점에 미리 결정해 놓을 수 있다.
 * -> 언어에 따라 컴파일 시점이 아닌 실행시점에 super의 대상이 결정될 수도 있다(ex. 스칼라의 트레이드)
 * 동적 바인딩, self 참조, super 참조는 상속을 이용해 다형성을 구현하고 코드를 재사용하기 위한 가장 핵심적인 재료다.
 * 동적 바인딩과 self 참조는 동일한 메시지를 수신하더라도 객체의 타입에 따라 적합한 메서드를 동적으로 선택할 수 있게 한다. super 참조는 부모 클래스의 코드에 접근할 수 있게 함으로써 중복코드를 제거할 수 있게 한다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
