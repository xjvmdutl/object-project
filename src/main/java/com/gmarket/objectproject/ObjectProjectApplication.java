package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 객체는 동적이고 살아 움직이는 존재이다. 프로그래밍을 위해 사용하는 도구(텍스트)는 정적이다. -> 객체는 동적, 프로그램은 정적이다
 * 프로그램 실행 구조를 표현하는 움직이는 모델을 동적 모델, 코드의 구조를 담는 모델을 정적 모델이라고 부른다.
 * 훌룡한 객체지향 프로그램을 작성하기 위해서는 동적 모델과 정적 모델을 조화롭게 버무릴 수 있는 능력이 필요하다.
 * 객체지향의 세계에서 동적 모델은 객체와 협력으로 구성된다. -> 객체는 다른 객체와 협력하면서 애플리케이션의 기능을 수행한다.
 * 객체지향의 세계에서 정적 모델은 타입과 관계로 구성된다. -> 타입은 객체를 분류하기 위한 틀로서 동일한 타입에 속하는 객체들이 수행할 수 있는 모든 행동들을 압축해서 표현한 것이다.(일반적으로 클레스로 구성된 모델)
 * 정적 모델은 동적 모델에 의해 주도돼야 하고 동적 모델이라는 토대 위에 세워져야 한다. 프로그램 코드 안에 담아지는 정적 모델은 객체 사이의 협력에 기반해야 한다.
 * 동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 하는 중요한 요소는 변경이다. 설계가 필요한 이유는 변경을 수용할 수 있는 코드를 만들기 위해서다.
 * 변경을 수용할 수 있는 코드
 * - 수정이 용이한 코드란 응집도가 높고 결합도가 낮으며 단순해서 쉽게 이해할 수 있는 코드다.
 * - 유연한 코드란 동일한 코드를 이용해 다양한 컨텍스트에서 동작 가능한 협력을 만들 수 있는 코드다. 유연성의 관점에서 작성된 코드는 객체 사이의 다양한 조합을 지원해야 한다.
 * - 수정이 용이한 코드와 유연한 코드에 대한 욕구는 중복 코드를 제거하게 만드는 가장 큰 압력이다. 중복코드가 많을수록 하나의 개념을 변경하기 위해 여려 곳의 코드를 한꺼번에 수정해야한다.
 *   유연한 코드를 향해 나아가다 보면 서로 다른 컨텍스트 사이의 공통점을 하나의 코드로 모아야 하는 상황에 직면하고 이런 필요성이 중복 코드를 제거하고 새로운 추상화를 도입하게 만든다.
 * 좋은 설계는 객체사이의 협력과 행동을 표현하는 모델을 기반으로 해야한다.
 *
 * 행동이 코드를 결정한다.
 * 협력에 참여하는 객체의 행동이 객체의 정적 모델을 결정해야 한다. 리스코프 치환 원칙에 따라 클라이언트의 관점에서 대체 가능성을 제공해야 한다.
 * 객체의 정적 모델은 동적 모델이라는 토대 없이는 완전해질 수 없다. 중요한 것은 객체가 외부에 제공하는 행동이다.
 * 정적 모델을 설계하는 이유는 단지 행동과 변경을 적절하게 수용할 수 있는 코드 구조를 찾는 것이어야 한다.
 * 정적 모델을 미리 결정하고 객체의 행동을 정적 모델에 맞춰서는 안된다. 동적 모델이 정적 모델을 결정해야 한다.
 * 만약 정적 모델이 협력에 적합하지 않다면 정적 모델을 지속적으로 개선하라.
 *
 * 변경을 고려하라
 * 객체가 제공하는 행동의 측면에서 적절하게 정적모델을 고려하더라도 변경을 고려하지 않는다면 유지보수하기 어려운 코드가 만들어 진다.
 * 동일한 행동을 제공하는 정적 모델이 있다면 항상 현재의 설계에서 요구되는 변경을 부드럽게 수용할 수 있는 설계를 선택해라
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
