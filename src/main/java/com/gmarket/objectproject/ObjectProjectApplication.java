package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 명령과 쿼리를 분리 하더라도 명령으로 인해 발생하는 부수효과를 명확하게 표현하는 데는 한계가 있다
 * 주석으로 부수효과를 서술하는 것도 가능하겠지만 파급 효과를 명확하게 전달하기가 쉽지 않을뿐더러 시간이 흐를수록 구현을 정확하게 반영하지 못할 가능성도 높다.
 * 메서드 구현이 단순하다면 내부를 살펴보는 것만으로도 부수효과를 쉽게 이해할 수 있지만, 구현이 복잡하고 부수효과를 가진 다수의 메서드들을 연이어 호출하는 코드를 분석하는 경우에는 실행 결과를 예측하기 어려울 수 밖에 없다.
 * 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다. -> 명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단인 계약에 의한 설계가 필요하다.
 * 계약에 의한 설계를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 저으이하고 문서화 할 수 있다.
 * 클라이언트 개발자는 오퍼레이션의 구현을 살펴보지 않더라도 객체의 사용법을 쉽게 이해할 수 있으며, 계약은 실행 가능하기 떄문에 구현에 동기화돼 있는지 여부를 런타임에 검증할 수 있다.
 * 계약에 의한 설계는 클래스의 부수효과를 명시적으로 문서화하고 명확하게 커뮤니케이션할 수 있을 뿐만 아니라 실행 가능한 검증도구로써 사용할 수 있다.
 *
 * 부수효과를 명시적으로
 * 프로그래밍 언어로 작성된 인터페이스는 객체가 수신할 수 있는 메시지는 저으이할 수 있지만 객체 사이의 의사소통 방식은 명확하게 정의할 수 없다.
 * 협력을 위해 필요한 약속과 제약은 인터페이스를 통해 전달할 수 없기 때문에 협력과 관련된 상당한 내용이 암시적인 상태로 남게된다.
 * c#의 계약에 의한 설계 라이브러리인 Code Contracts를 사용하면 IsSatisfied메서드의 실행 결과가 true일 때만 Reschedule 메서드를 호출할 수 있다는 사실을 명확하게 표현할 수 있다.
 *
 * 계약
 * 우리가 집을 리모델링을 하고 싶다고 가정하면 적절한 인테리어 전문가에게 위탁하고 계약을 체결할 것이다.
 * - 각 계약 당사자는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행한다.
 * - 각 계약 당사자의 이익ㅇ과 의무는 계약서에 문서화 한다.
 * 여기서 핵심은 한쪽의 의무가 반대쪽의 권리가 된다는 것이다.
 * 두 계약 당사자 중 어느 한쪽이라도 계약서에 명시된 내용을 위반한다면 계약은 정상적으로 완료되지 않을 것이다.\
 * 계약상 우리가 고용주라고 하더라도 인테리어 전문가가 계약을 이행하는 구체적인 방식에 대해서는 간섭하지 않는다는 것을 기억하자.
 * -> 리모델링 공사를 진행하는 구체적인 방법은 인테리어 전문가가 자유롭게 결정할 수 있으며, 작업 방식과 상관없이 리모델링 결과가 만족스럽다면 여러분은 인테리어 전문가가 계약을 정상적으로 이행한 거승로 간주할 것이다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
