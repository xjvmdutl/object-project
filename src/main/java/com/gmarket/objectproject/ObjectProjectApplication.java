package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 디미터 법칙
 * 이 코드의 가장 큰 단점은 Reservation와 인자로 전달된 Screening 사이의 결합도가 너무 높기 때문에 Screening의 내부 구현을 변경할 떄마다 ReservationAgency도 함께 변경된다.
 * -> ReservationAgency는 사소한 변경에도 이리저리 흔들리는 의존성의 집결지이다.
 * 협력하는 객체의 내부구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제한된 원칙이 디미터 법칙(객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라)이다.
 * 디미터 법칙은 디미터라는 프로젝트를 진행하던 도중 객체들의 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다는 사실을 발견했다.
 * 디미터 법칙을 따르기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 해야한다.
 * 모든 클래스 c와 c에 구현된 모든 메서드 m에 대해서, m이 메시지를 전송할 수 있는 모든 객체는 m의 인자로 전달된 클래스(c자체 포함), c의 인스턴스 변수의 클래스의 인스턴스여야한다.
 * 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 한다고 이해해도 된다.
 * - this 객체
 * - 메서드의 매개변수
 * - this의 속성
 * - this의 속성인 컬렉션의 요소
 * - 메서드 내에서 생성된 지역 객체
 * 디미터 법칙을 따르면 부끄럼타는 코드(불필요한 어떤 것도 다른 객체에게 보여주지 않으며 다른 객체의 구현에 의존하지 않는 코드)를 작성할 수 있다.
 * 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다. -> 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.
 * 디미터 법칙을 위반하는 예제 = screening.getMovie().getDiscountConditions();
 * 기차 충돌: 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송하는 코드를 기차 충돌이라고 한다.
 * 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.
 * -> 메시지 수신자의 캡슐화는 무너지고, 메시지 전송자가 메시지 수신자의 내부 구현에 강하게 결합된다.
 * 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다.
 *
 * 묻지 말고 시켜라
 * screening이 내부의 Movie를 접근하는 대신 직접 요금을 계산하도록 요청했다. -> 이러한 스타일의 메시지 작성 방식을 "묻지 말고 시켜라" 방식 이라 한다.
 * 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다. -> 우리가 구현하고 있는 로직은 메시지 수신자가 담당해야할 책임일 것이다.
 * 묻지말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다 -> 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.
 * 묻지 말고 시켜라 원치, 디미터 법칙은 훌룡한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다.
 * 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라
 *
 * 의도를 드러내는 인터페이스
 * 메서드를 명명하는 방법
 * 1) 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것 -> 메서드의 이름은 내부의 구현 방법을 드러낸다(isSatisfiedByPeriod, isSatisfiedBySequence)
 *  단점
 *  > 메서드에 대해 제대로 커뮤니케이션하지 못한다
 *    -> isSatisfiedByPeriod, isSatisfiedBySequence 모두 할인조건을 판단하는 동일한 작업이지만, 이름이 다르기 때문에 내부 구현을 정확히 모르면 두 메서드가 같은 작업을 하는지 알 수 없다
 *  > 메서드 수준에서 캡슐화를 위반한다 -> 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다.
 * 2) 어떻게가 아니라 무엇을 하는지를 드러내는 것이다. -> 무엇을 하는지를 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들뿐만 아니라 유연한 코드를 낳는 지름길이다.
 * 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력안에서 수행해야 하는 책임에 관해 고민해야 한다.
 * 자바 같은 정적 타이핑 언어에서 단순히 메서드의 이름이 같다고 해서 동일한 메시지를 처리할 수 있는것은 아니다 -> 동일한 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어야 한다.
 * 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.
 * 의도를 드러내는 선택자 : 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴
 * 하나의 구현을 가진 메시지의 이름을 일반화하도록 도와주는 방법으로는 매우 다른 두번째 구현을 상상하라, 그리고 해당 메서드에 동일한 이름을 붙힌다고 상상해라
 * 의도를 드러내는 인터페이스: 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야한다.
 * 방법이 아닌 의도를 표현하는 추상적인 인터페이스 뒤로 모든 까다로운 메커니즘을 캡슐화해야한다. 도메인의 퍼블릭 인터페이스에서는 관계와 규칙을 시행하는 방법이 아닌 이벤트와 규칙 그 자체만 명시한다.
 * 객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다.
 *
 *
 *
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }

}
