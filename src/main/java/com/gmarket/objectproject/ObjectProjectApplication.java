package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입이라고 부른다.
 * 의존성 주입이라고 부르는 이유는 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문이다.
 * 의존성 주입은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내 외부에서 필요한 런타임 의존성을 전달할 수있도록 만드는 방법을 포괄하는 명칭이다.
 * 의존성을 해결하는 세가지 방법(Client 클래스 확인)
 * - 생성자 주입: 객체를 생성하는 시점에 생성자를 통한 의존성 해결
 * - setter 주입: 객체 생성 후, setter 메서드를 통한 의존성 해결
 * - 메서드 주입: 메서드 실행 시 인자를 이용한 의존성 해결
 *
 * 프로퍼티 주입과 인터페이스 주입
 * setter 주입은 자바에서 유래하였으며 C#에서는 프로퍼티를 통해 setter를 대체 하는데 따라서 C#에서는 프로퍼티 주입이라 부른다.
 * 인터페이스 주입은 주입할 의존성을 명시하기 위해 인터페이스를 사용해 의존성을 주입한다.
 * -> 인터페이스 주입은 근본적으로 setter와 동일하나 어떤 대상을 어떻게 주입할 것인지를 인터페이스를 통해 명시적으로 선언한다는 차이만 있다.
 *
 * 숨겨진 의존성은 나쁘다.
 * 의존성 주입 외에 의존성을 해결하는 대표적인 방법: Service Locator
 * Service Locator: 의존성을 해결할 객체들을 보관하는 일종의 저장소로 객체가 직접 Service Locator에게 의존성을 해결해줄 것을 요청한다.
 * Service Locator 패턴의 가장 큰 단점은 의존성을 감추는 것이다 -> Movie의 Public 인터페이스 어디에도 의존성에 대한 정보가 표시돼어 있지않다(Movie는 DisplacePolicy에 의존한다)
 * -> 의존성이 암시적이며 코드 깊은 곳에 숨겨져 있다.
 * 단순히 Movie를 생성하는 코드를 작성한 개발자는 Movie가 온전히 생성될 것으로 예측하지만, NullPointException이 발생하게 된다 -> Service Locator를 통해 의존성을 해결하지 않았기 때문
 * 의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 컴파일 타임이 아닌 런타임에 가서야 발견이 된다는 것을 알수 있다.
 * -> 숨겨진 의존성이 이해하기 어렵고 디버깅이 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아닌 실행 시점으로 미루기 때문이다.
 * 의존성을 숨기는 코드는 단위 테스트 작성도 어렵다.
 * -> Service Locator는 내부적으로 정적 변수를 사용해 객체들을 관리하기 때문에 모든 단위 테스트 케이스에 걸쳐 Service Locator의 상태를 공유한다. 이는 각 단위 테스트는 서로 고립돼야 한다는 단위 테스트 기본 원ㅌ칙을 위반한 것이다.
 * -> 단위 테스트가 서로 간섭없이 실행되기 위해서는 Movie를 테스트하는 모든 단위 테스트 케이스에서 Movie를 생성하기 전에 Service Locator에 필요한 DiscountPolicy의 인스턴스를 추가하고 끝날 떄마다 추가된 인스턴스를 제거해야한다.
 * 모든 원인은 숨겨진 의존성이 캡슐화를 위반했기 때문이다(인스턴스 변수의 가시성만 private로 선언하고 변경되는 내용만 숨겼다고 캡슐화가 아니다)
 * 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관접에서 훌룡한 코드며, 클래스의 사용법을 익히기 위해 구현 내부를 샅샅이 뒤져야 한다면 그 클래스의 캡슐화는 무너진 것이다.
 * 숨겨진 의존성이 가지는 가장 큰 문제는 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 강조한 것으로 캡슐화를 위반한다.
 * -> 결국 의존성을 구현 내부로 감추도록 강요하는 Service Locator는 캡슐화를 위반할 수 밖에 없다.
 * 숨겨진 의존성은 의존성의 대상을 설정하느 시점과 의존성이 해결되는 시점을 멀리 떨어트려 놓는다. -> 코드를 이해하기 어렵고, 디버깅하기 힘들게 한다.
 * 의존성 주입은 이러한 문제를 해결하며, 필요한 의존성은 클래스의 퍼블릭 인터페이스에 명시적으로 드러나기에 의존성을 이해하기 위해 코드 내부를 읽을 필요가 없고, 객체의 캡슐을 단단히 보호한다.
 * 의존성 관련 문제는 컴파일 타임에 잡을수 있고(필요 의존성이 없을 시 컴파일 에러 발생), 단위 테스트 작성 시에도 Service Locator에 객체를 추가할 필요도 없다
 * 명시적인 의존성이 숨겨진 의존성보다 좋으므로 가급적 의존성을 객체의 퍼블릭 인터페이스에 노출하자
 * -> 의존성 주입을 지원하는 프레임워크를 사용하지 못하는 경우나 깊은 호출 계층에 걸쳐 동일한 객체를 계속해서 전달해야 하는 고통을 견디기 힘든 경우 어쩔수 없이 Service Locator를 사용해야하는 경우도 있다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
