package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 코드 재사용 대 설계 재사용
 * 언어에 종속적인 구현 코드를 정의하지 않기 때문에 디자인 패턴을 적용하기 위해서는 설계 아이디어를 프로그래밍 언어의 특성에 맞춰 가공해야 하고 매번 구현 코드를 재작성해야 한다는 단점이 있다.
 * 재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다. 다양한 도메인에 재사용 가능한 컴포넌트라는 개념은 비현실적이라고 할 수 있다.
 * 가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다. 코드 재사용만을 강조하는 컴포넌트는 실패했다(추상적인 수준에서의 설계 재사용을 강조하는 디자인 패턴은 재사용을 위한 매번 유사한 코드를 작성해야만 한다)
 * 프레임워크란 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계 또는 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징 할 수 있는 애플리케이션의 골격을 의미한다.
 * 첫번째 정의가 프레임워크의 구조적인 측면에 초점을 맞춘다면 두번째 정의는 코드와 설계의 재사용이라는 프레임워크 사용 목적에 초점을 맞춘다.
 * 프레임워크는 코드를 재사용하면서 설계 아이디어를 재사용한다. 프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다. 또한 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 제공한다.
 * - 프레임워크는 애플리케이션에 대한 아키텍처를 제공한다. 즉 프레임워크는 클래스와 객체들의 분할, 전체 구조, 클래스와 객체들 간의 상호작용, 객체와 클래스 조합 방법, 제어 흐름에 대해 미리 정의한다.
 * - 프레임워크는 설계의 가변성을 미리 정의해 뒀기 때문에 애플리케이션 설계자나 구현자는 애플리케이션에 종속된 부분에 대해서만 설계하면 된다.
 * - 프레임워크는 애플리케이션 영역에 걸쳐 공통의 클래스들을 정의해서 일반적인 설계 결정을 미리 내려둔다. 프레임워크는 코드의 재사용보다 설계 자체의 재사용을 중요시한다.
 *
 * 상위 정책과 하위 정책으로 패키지 분리하기
 * 프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화라고 할 수 있다.
 * 협력을 일관성있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 캡슐화해야 한다. 그리고 협력을 구현하는 코드 안의 의존성은 가급적이면 추상 클래스나 인터페이스와 같은 추상화를 향하도록 작성해야한다.
 * 상위 정책은 상대적으로 변경에 안정되지만 세부 사항은 자주 변경된다. 만약 변하지 않는 상위 정책이 자주 변하는 세부 사항에 의존한다면 변경에 대한 파급효과로 인해 상위 정책이 불안정해질 것이다.
 * 상위정책이 세부 사항에 비해 재사용될 가능성이 높다.
 * 결국 상위 정책이 세부사항보다 더 다양한 상황에서 재사용될 수 있어야 한다는 것이다. 하지만 상위 정책이 세부 사항에 의존하게 되면 상위 정책이 필요한 모든 경우에 세부 사항도 항상 함께 존재해야 하기 때문에 상위 정책의 재사용성이 낮아진다.
 * 이 문제를 해결할 수 있는 가장 좋은 방법은 의존성 역전 원칙에 맞게 상위 정책과 세부 사항 모두 추상화에 의존하게 만드는 것이다.
 * 의존성 역전 원칙의 관점에서 세부 사항은 변경을 의미한다. 동일한 역할을 수행하는 객체들 사이의 협력 구조를 다양한 애플리케이션 안에서 재사용하는 것이 핵심이다.
 * 변하는 것과 변하지 않는 것을 서로 분리해야한다(변하는 것: 상위 정책에 속하는 역할들의 협력 구조, 변하지 않는 것: 구체적인 세부 사항)
 * 프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 배포 단위로 분리해야한다.
 * 첫 걸음은 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는 것이다.
 * 나아가 상위 정책을 구현하고 있는 패키지가 충분히 안정적이고 성숙했다면 하위 정책 패키지로부터 완벽히 분리해서 별도의 배포 단위로 만들 수 있다.
 * 프레임워크는 여러 애플리케이션에 걸쳐 일관성 있는 협력을 구현할 수 있게 해준다. 그리고 일관성있는 협력이 제공하는 다양한 장점들은 프레임워크에 대해서도 여전히 적용된다.
 *
 * 제어 역전 원리
 * 상위 정책을 재사용한다는 것은 결국 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용한다는 것을 의미한다. 시스템이 진화하는 방향에서항상 의존성 역전 원리를 따르는 설계가 존재해야 한다.
 * 훌룡한 객체지향 설계는 의존성이 역전된 설계이다.
 * - 사실 좋은 객체지향 설계의 증명이 바로 이와 같은 의존성의 역전이다. 프로그램이 의존성이 역전돼 있다면 이것은 객체지향 설계를 갖는 것이다. 그 의존성이 역전돼 있지 않다면 절차적 설계를 갖는것이다.
 * 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이다. 의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.
 * 상위 정책이 구체적인 하위 정책에 의존하는 전통적인 구조는 상위 정책의 코드가 하부의 구체적인 코드를 실행 시키고, 재활용이 ,재사용이 가능한 라이브러리나 툴킷으로 코드를 호출한다.
 * 의존성 역전을 역전시킨 객체지향 구조에서는 반대로 프레임워크가 애플리케이션에 속하는 서브 클래스의 메서드를 호출한다. 이를 제어 역전의 원리, 할리우두 원리라고 한다
 * 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 그리고 이렇게 완성되지 않은 채 남겨진 동작을 훅이라고 부른다.
 * 훅의 구현 방식을 애플리케이션의 컽텍스트에 따라 달라진다. 혹은 프레임워크 에서 호출하는 프레임워크의 책임이다. 재정의된 훅은 제어 약전 관리에 따라 프레임워크가 원한는 시점에 호출된다.
 * 협력을 제어하는 것은 프레임워크이다. -> 객체지향의 시대에는 그저 프레임워크가 호출하는 코드를 작성해야많 한다.
 * 우리의 코드는 수동적이다. 프레임워크가 우리의 코드를 호출해 줄 때까지 그저 넋 놓고 기다리고 있을 수 밖에 없다.
 * - 설계 수준의 재사용은 애플리케이션과 기반이 되는 소프트웨어 간에 제어를 바꾸게 한다.
 * */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
