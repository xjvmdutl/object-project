package com.gmarket.objectproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 객체들의 협력 구조가 서로 다른 경우에는 코드를 이해하기도 어렵고 코드 수정으로 인해 버그가 발생할 위험성도 높아진다. 유사한 요구사항을 계속 추가햐야 하는 상황에서 각 협력이 서로 다른 패턴을 따를 경우에는 전쳊거인 설계의 일관성이 서서히 무너지게 된다.
 * 객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다. 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다. -> 일관성은 설계에 드는 비용을 감소 시킨다.
 * 과거의 해결 방법을 반복적으로 사용해서 유사한 기능을 구현하는 데 드는 시간과 노력을 대폭 줄일 수 있기 때문이다. 또한 코드가 이해하기 쉬워진다.
 * 가능하면 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하라. 유사한 기능을 구현하기 위해 유사한 협력 방법을 따를 경우 코드를 이해하기 위해 필요한 것은 약간의 기억력과 적응력 뿐이다.
 *
 * 구간별 방식 구현하기
 * 현재 구현의 가장 큰 문제점은 이 클래스들이 유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다는 것이다.
 * 기본 정책을 구현한다는 공통을 목적은 공유하지만 정책을 구현하는 방식은 완전히 다르다. -> 개념적으로는 연관돼 있지만 구현 방식에 있어서는 완전히 제가각이라는 것이다.
 * 비일관성은 2가지 상황에서 발목을 잡는다 1) 새로운 구현을 추가해야 하는 상황이다. 2) 기존의 구현을 이해해야 하는 상환이다. ( 이것이 방해가 되는 이유는 개발자로서 우리가 수행하는 대부분의 활동이 코드를 추가하고 이해하는 일과 깊게 연관돼 있기 때문이다.
 * 1) 새로운 구현을 추가해야 하는 상황
 * TimeOfDayDiscountPolicy, DayOfWeekDiscountPolicy, FixedFeePolicy를 구현한 방식은 완전히 다르다. -> 세가지 기본 정책에 대한 세가지 서로 다른 구현 방식이 존재하는 것이다.
 * 어떤 방식을 선택하더라도 구간별 방식을 구현하는 데는 문제가 없다. 하지만 전체적인 일관성이라는 측면에서 보면 어떤 방식을 따르더라도 문제가 커지게 된다.
 * 현재의 설계는 새로운 기본 정책을 추가하면 추가할수록 코드 사이의 일관성은 점점 더 어긋나게 되는 것이다.
 * 2) 기존의 구현을 이해햐야 하는 상황
 * 요일별 방식의 구현을 이해해도 시간대별 방식을 이해하기 어렵고, 요일별 방식의 구현을 이애한 후 고정 요금 방식의 구현을 보아도 구조를 분석하기 쉽지 않다.
 * 서로 다른 구현 방식이 코드를 이해하는 데 오히려 방해가 될 뿐이다.
 * 대부분의 사람들은 유사한 요구사항을 구현하는 코드는 유사한 방식으로 구현될 것이라고 예상한다. 하지만 유사한 요구사항이 서로 다른 방식으로 구현돼 있다면 요구사항이 유사하다는 사실 자체도 의심하게 될 것이다.
 * -> 유사한 요구사항을 구현하는 서로 다른 구조의 코드는 코드를 이해하는 데 심리적인 장벽을 만든다.
 * 결론은 유사한 기능을 서로 다른 방식으로 구현해서는 안된다는 것이다. 일관성 없는 설계와 마주한 개발자는 여러 가지 해결 방법 중에서 현재의 요구사항을 해결하기에 가장 적절한 방법을 찾아야 하는 부담을 안게 된다.
 * 유사한 기능은 유사한 방식으로 구현해야 한다. 객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것 뿐이므로 유지보수가 가능하 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것이다.
 */
@SpringBootApplication
public class ObjectProjectApplication {
  public static void main(String[] args) {
    SpringApplication.run(ObjectProjectApplication.class, args);
  }
}
